<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Nothing is Everything">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Qing Yun</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="http://ls-a.me/">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="posts/ath10k-firmware-crashed/" type="text/html">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://ls-a.me/">

                <span id="blog-title">Qing Yun</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="archive.html">Archive</a>
                </li>
<li>
<a href="categories/">Tags</a>
                </li>
<li>
<a href="rss.xml">RSS feed</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            

    


    
<div class="postindex">
    <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/ath10k-firmware-crashed/" class="u-url">ath10k firmware crashed</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Tao Qingyun
            </span></p>
            <p class="dateline"><a href="posts/ath10k-firmware-crashed/" rel="bookmark"><time class="published dt-published" datetime="2018-03-26T21:45:15+08:00" title="2018-03-26 21:45">2018-03-26 21:45</time></a></p>
                <p class="commentline">
        
    <a href="posts/ath10k-firmware-crashed/#disqus_thread" data-disqus-identifier="cache/posts/ath10k-firmware-crashed.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>
前些天，我的电脑总是时不时的断网，每次我得重启dhcpcd服务。 我的系统是
Arch Linux，网络用的是dhcpcd＋wpa_supplicant。首先确定的是网络本身没有
问题。 dmesg看了一眼，发现这样的信息" ath10k_pci 0000:3a:00.0:
firmware crashed!"。网上搜了一下，了 解到aht10k是一个无线网卡驱动，专
为Qualcom Atheros QCA988x（高通）系列， 详情见这里
<a href="https://wireless.wiki.kernel.org/en/users/drivers/ath10k">https://wireless.wiki.kernel.org/en/users/drivers/ath10k</a>。
</p>

<blockquote>
<p>
$ lspci
……
3a:00.0 Network controller: Qualcomm Atheros QCA6174 802.11ac Wireless Network Adapter (rev 32)
3b:00.0 Unassigned class [ff00]: Realtek Semiconductor Co., Ltd. RTS525A PCI Express Card Reader (rev 01)
3c:00.0 Non-Volatile memory controller: Toshiba America Info Systems XG4 NVMe SSD Controller (rev 01)
</p>
</blockquote>

<p>
可以看到我的网卡正是Qualcom Atheros，由此可以确定断网问题和ath10k有关。
</p>

<p>
升级firemare可能能解决问题，升级方法也很简单，只要直接替换对应的firmware镜像
文件就可以了。它在 <a href="https://github.com/kvalo/ath10k-firmware">ath10-firmware.git</a> 中开发，最终合并到 <a href="https://git.kernel.org/cgit/linux/kernel/git/firmware/linux-firmware.git/">linux-firmware.git</a> 中，我系
统现在使用的版本是20180119.2a713be-1，这已经是Arch的最新版了。我需要从
它的git库中下载最新的。但是这个库看起来非常大，包含了各种设备的
firmware，而我只需要其中的一个。还好 <a href="https://git.kernel.org%20">https://git.kernel.org%20</a> 提供了一种
plan模式，你可以直接用HTTP下载单个文件。打开我设备型号对应的目录：
</p>

<blockquote>
<p>
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/ath10k/QCA6174/hw3.0/">https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/ath10k/QCA6174/hw3.0/</a>
<i>ath10k/QCA6174/hw3.0</i>
../
board-2.bin
board.bin
firmware-4.bin
firmware-6.bin
notice_ath10k_firmware-4.txt
notice_ath10k_firmware-6.txt
</p>
</blockquote>

<p>
还不只一个文件，那就整个目录替换吧。一个一个下又点麻烦，用wget。
</p>

<blockquote>
<p>
wget -c -e robots=off -r -l1 –debug <a href="https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/ath10k/QCA6174/hw3.0/">https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/ath10k/QCA6174/hw3.0/</a>
</p>
</blockquote>

<p>
开始时一值只能下到一个index.html，看了一边手册，确信-r是递归下载，也没
找到其他又用的选项。打开debug模式，原来是wget遵循了robots规则，而
<a href="https://git.kernel.org">https://git.kernel.org</a> 禁止一切爬虫。然后我在wget的info找到了关闭它的
方法 <code>robots=off</code> 。而这时我的网络已经快崩溃了，重启一次dhcpcd只能维持不到
半分钟，还好wget被设计成在慢速或不可靠网络下也保持健壮性，失败的时候会重
连。这样在这种艰苦的条件下，这几个文件终于被下载下来了。
</p>

<p>
接着就是备份原来的目录，复制新的firmware文件。reboot。一切恢复正常。
</p>

<p>
firmware crashed 的原因应该是我最近一次系统升级导致的，内核升级到
4.15.10,ath10k驱动和firmware不兼容导致的。
</p>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/dns/" class="u-url">理解DNS</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Tao Qingyun
            </span></p>
            <p class="dateline"><a href="posts/dns/" rel="bookmark"><time class="published dt-published" datetime="2016-09-11T20:23:16+08:00" title="2016-09-11 20:23">2016-09-11 20:23</time></a></p>
                <p class="commentline">
        
    <a href="posts/dns/#disqus_thread" data-disqus-identifier="cache/posts/dns.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<h3>简介</h3>
<p>域名系统（Domain Name System），它最常用的功能就是把域名解析成IP。什么是域名（domain name），计算机在网络中的名字。它能让我们通过名字来找到网络中的机器，而不能去记住那些无意义的IP地址。可以把它想象成一个地址薄，上面记录着域名和IP的对应关系。事实上，在早期确实有这样一个文件HOSTS.TXT，它被网络中的所有主机所共享。但随着网络结构的改变，这种方式变得不可行。现在的域名系统是一个分布式的数据库，与之对应的，域名本身也是分层的。</p>
<h3>域名结构</h3>
<p>域名是一个树形结构。从下到上以<code>.</code>连接，如<code>A.ISI.EDU</code></p>
<pre class="code literal-block"><span></span>                                   |
                                   |
             +---------------------+------------------+
             |                     |                  |
            MIL                   EDU                ARPA
             |                     |                  |
             |                     |                  |
       +-----+-----+               |     +------+-----+-----+
       |     |     |               |     |      |           |
      BRL  NOSC  DARPA             |  IN-ADDR  SRI-NIC     ACC
                                   |
       +--------+------------------+---------------+--------+
       |        |                  |               |        |
      UCI      MIT                 |              UDEL     YALE 
                |                 ISI
                |                  |
            +---+---+              |
            |       |              |
           LCS  ACHILLES  +--+-----+-----+--------+
            |             |  |     |     |        |
            XX            A  C   VAXA  VENERA Mockapetris
</pre>


<h3>记录（Resouce Record）</h3>
<p>实现上一个域名可以对应多个信息，而IP地址只是其中的一个。这样一个信息被称为这个域名的一个记录或者RR，记录是分类型，比如IP地址是一个A类记录。其他记录类型有AAAA（IPv6地址）、MX（邮件服务地址）、NS（域名服务器）等。DNS被设计为可扩展的，记录类型是可以增加的，因此一个域名理论上可以被解析为任意的消息。</p>
<ul>
<li>A</li>
<li>SOA</li>
<li>NS</li>
<li>PTR</li>
</ul>
<h3>逆向解析</h3>
<h3>Zone Transfer</h3>
<p>一个域名服务器负责整个域名空间的一部分，就像上图中树中的一棵子树。这样的部分空间叫做<code>Zone</code>。每个Zone维护着一个像HOSTS.TXT的文件，上面记录着该空间的所有域名信息。如：</p>
<pre class="code literal-block"><span></span>co.kp.          432000  IN  SOA ns1.co.kp. root.co.kp. 2013082900 28800 86400 1209600 86400
co.kp.          432000  IN  NS  ns1.co.kp.
co.kp.          432000  IN  NS  ns2.co.kp.
ns1.co.kp.      432000  IN  A   175.45.176.15
ns2.co.kp.      432000  IN  A   175.45.176.16
star.co.kp.     432000  IN  NS  ns1.star.co.kp.
star.co.kp.     432000  IN  NS  ns2.star.co.kp.
ns1.star.co.kp.     432000  IN  A   175.45.176.15
ns2.star.co.kp.     432000  IN  A   175.45.176.16
co.kp.          432000  IN  SOA ns1.co.kp. root.co.kp. 2013082900 28800 86400 1209600 86400
</pre>


<p>一个Zone可以有多个域名服务器，以防止单点故障。其中有一台是主服务器，域名信息的改变最先是在主服务器上的，这就需要一个方法来同步所有服务器。DNS使用Zone transfer，与其他DNS消息不同，Zone transfer可以使用TCP，以保证域名信息传输的可靠性，完整性。处于安全考虑，域名服务器可以关闭Zone trnasfer，或者增加一些限制，如只允许指定IP地址的服务器使用Zone transfer。（最近朝鲜顶级域名服务器的错误配置，允许Zone transfer，DNS数据泄露[https://github.com/mandatoryprogrammer/NorthKoreaDNSLeak]）</p>
<h3>DNS实现（组成，报文结构，通讯协议）</h3>
<h3>现实中的DNS（注册域名， 搭建DNS服务器）</h3>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/python-name/" class="u-url">python值传递 or 引用传递</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Tao Qingyun
            </span></p>
            <p class="dateline"><a href="posts/python-name/" rel="bookmark"><time class="published dt-published" datetime="2016-08-22T22:23:25+08:00" title="2016-08-22 22:23">2016-08-22 22:23</time></a></p>
                <p class="commentline">
        
    <a href="posts/python-name/#disqus_thread" data-disqus-identifier="cache/posts/python-name.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>当被问到python是值传递还是引用传递的时候，你要回答都不是。</p>
<p>要理解这个问题，首先要知道Python中变量，赋值是怎么一回事，它和C语言有很大不同。
在C语言中，变量可以想象成一个只能装特定类型值的盒子，<code>int a = 5</code>，把数字5放到<code>a</code>盒子中。<code>int b = a</code>，则把<code>a</code>中的5复制一份放入<code>b</code>盒子中。而在Python中，通常的赋值过程被称作<a href="https://docs.python.org/3/reference/executionmodel.html"><strong>name binding</strong></a>，这还包括类和函数定义，import语句，当然还有函数的形参。Python中一切都是对象，即使是数字5，那么现在<code>a = 5</code>的意思就是为5这个对象绑定了一个名字<code>a</code>。你可以把变量想象成一个标签，它现在贴在5这个对象上。<code>b = a</code>, 就是为5又打了个新标签<code>b</code>。</p>
<p>现在就可以很容易解释下面这两个列子：</p>
<pre class="code literal-block"><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">fun</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># 1</span>
</pre>


<pre class="code literal-block"><span></span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">fun</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>  <span class="c1"># [1]</span>
</pre>


<p>有人把这种现象归因于可变对象和不可变对象的区别，而其实这两者并没有可比性，如果把第二个例子改一下：</p>
<pre class="code literal-block"><span></span><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">fun</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>  <span class="c1"># []</span>
</pre>


<p>列表是可变的啊，为什么最后没有打印<code>[1, 2, 3]</code>？在<code>fun</code>开始执行时形参<code>l</code>和<code>fun</code>外的<code>l</code>（不同的作用域）都贴在<code>[]</code>上，当<code>l = [1, 2, 3]</code>被执行，只是把形参<code>l</code>从<code>[]</code>上撕下贴到了<code>[1, 2, 3]</code>上，而<code>fun</code>外的<code>l</code>却依然贴在<code>[]</code>上。</p>
<p>那么Python的参数传递方式到底该叫什么呢？<code>call-by-object-reference</code>，<code>call-by-assignment</code>？在CPython的实现中，名字也是一个对象，而所有的对象都通过<code>PyObject *</code>来引用，名字和对象的绑定关系就是保存在一个Python的字典结构中。不管是赋值还是参数传递，都只是改变了作用域字典中名字对应的对象的引用。也许<code>call-by-object-reference</code>更好些。</p>
<h3>reference</h3>
<p><a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">how-do-i-pass-a-variable-by-reference</a></p>
<p><a href="http://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/">Is Python pass-by-reference or pass-by-value?</a></p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/read-memcached-120/" class="u-url">memcached-1.2.0 源码解读</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Tao Qingyun
            </span></p>
            <p class="dateline"><a href="posts/read-memcached-120/" rel="bookmark"><time class="published dt-published" datetime="2016-08-18T20:21:26+08:00" title="2016-08-18 20:21">2016-08-18 20:21</time></a></p>
                <p class="commentline">
        
    <a href="posts/read-memcached-120/#disqus_thread" data-disqus-identifier="cache/posts/read-memcached-1.2.0.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p><em>关键词</em> ： libevent，状态机，内存分配，hash表</p>
<hr>
<p>memcached是一个免费开源的高性能分布式(由客户端提供)对象缓存系统。这篇将对memcached 1.2.0的源码的进行一点解读，这是我能找到的最早的发行版。协议定义在<code>doc/protocol.txt</code>下，代码量在3500行左右：</p>
<pre class="code literal-block"><span></span>$ wc *.<span class="o">[</span>ch<span class="o">]</span>
   <span class="m">186</span>    <span class="m">844</span>   <span class="m">5912</span> assoc.c
    <span class="m">71</span>    <span class="m">328</span>   <span class="m">1963</span> config.h
    <span class="m">70</span>    <span class="m">370</span>   <span class="m">2649</span> daemon.c
   <span class="m">322</span>   <span class="m">1056</span>   <span class="m">8560</span> items.c
  <span class="m">2282</span>   <span class="m">7820</span>  <span class="m">68519</span> memcached.c
   <span class="m">278</span>   <span class="m">1379</span>   <span class="m">9781</span> memcached.h
   <span class="m">356</span>   <span class="m">1392</span>  <span class="m">10717</span> slabs.c
  <span class="m">3565</span>  <span class="m">13189</span> <span class="m">108101</span> total
</pre>


<p>编译需要安装libevent依赖和autotools工具。</p>
<h3>libevent</h3>
<p>libevent提供了一种当文件描述符的事件(读，写)发生时执行回调函数的机制，也支持信号和超时回调。memcached用的是libevent的1.x版本，使用了这样几个API：</p>
<ul>
<li><code>struct event_base *event_init(void)</code></li>
<li><code>void event_set(struct event *, int, short, void(*)(int, short, void *), void *)</code></li>
<li><code>int event_add(struct event *ev, const struct timeval *timeout)</code></li>
<li><code>int event_del(struct event *)</code></li>
<li><code>int event_loop(int)</code></li>
</ul>
<p>memcached的<code>main</code>函数首先调用<code>event_init</code>，这是使用libevent的必须步骤。接着<code>main</code>函数创建监听socket，并为其描述符的读事件设置回调函数。另外还添加了两个周期性事件：更新当前时间，一秒一次；删除items，5秒一次。最后<code>event_loop</code>被调用，事件循环正式开始。 随着连接的建立、协议的通讯，事件通过<code>event_add</code>和<code>event_del</code>动态的添加和删除。</p>
<h3>状态转化</h3>
<p>memcached将一次链接的所有信息都封装在结构体<code>struct conn</code>中，包括socket的文件描述符，事件，当前状态，输入输出缓存，items等。部分结构如下</p>
<pre class="code literal-block"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span>    <span class="n">sfd</span><span class="p">;</span>
    <span class="kt">int</span>    <span class="n">state</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">event</span> <span class="n">event</span><span class="p">;</span>

    <span class="kt">char</span>   <span class="o">*</span><span class="n">rbuf</span><span class="p">;</span>   <span class="cm">/* buffer to read commands into */</span>

    <span class="kt">char</span>   <span class="o">*</span><span class="n">wbuf</span><span class="p">;</span>

    <span class="kt">char</span>   <span class="o">*</span><span class="n">ritem</span><span class="p">;</span>  <span class="cm">/* when we read in an item's value, it goes here */</span>


    <span class="kt">void</span>   <span class="o">*</span><span class="n">item</span><span class="p">;</span>     <span class="cm">/* for commands set/add/replace  */</span>
    <span class="kt">int</span>    <span class="n">item_comm</span><span class="p">;</span> <span class="cm">/* which one is it: set/add/replace */</span>


    <span class="cm">/* data for the mwrite state */</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">;</span>
    <span class="kt">int</span>    <span class="n">iovsize</span><span class="p">;</span>   <span class="cm">/* number of elements allocated in iov[] */</span>
<span class="p">}</span> <span class="n">conn</span><span class="p">;</span>
</pre>


<p>conn结构中的state记录这个连接的当前状态，一共定义了7个状态。</p>
<pre class="code literal-block"><span></span><span class="k">enum</span> <span class="n">conn_states</span> <span class="p">{</span>
    <span class="n">conn_listening</span><span class="p">,</span>  <span class="cm">/* the socket which listens for connections */</span>
    <span class="n">conn_read</span><span class="p">,</span>       <span class="cm">/* reading in a command line */</span>
    <span class="n">conn_write</span><span class="p">,</span>      <span class="cm">/* writing out a simple response */</span>
    <span class="n">conn_nread</span><span class="p">,</span>      <span class="cm">/* reading in a fixed number of bytes */</span>
    <span class="n">conn_swallow</span><span class="p">,</span>    <span class="cm">/* swallowing unnecessary bytes w/o storing */</span>
    <span class="n">conn_closing</span><span class="p">,</span>    <span class="cm">/* closing this connection */</span>
    <span class="n">conn_mwrite</span>      <span class="cm">/* writing out many items sequentially */</span>
<span class="p">};</span>
</pre>


<p>其中<code>conn_listening</code>只属于监听socket，不会改变。当新连接建立时，分配一个conn结构并初始化为<code>conn_read</code>状态。</p>
<ul>
<li><code>set|add|replace &lt;key&gt; &lt;flags&gt; &lt;exptime&gt; &lt;bytes&gt;\r\n</code></li>
</ul>
<p>这一类命令分为2部分，<code>text line</code>和<code>unstructured data</code>
当memcached接收完<code>text line</code>后，<code>conn_read</code>--&gt;<code>conn_nread</code>，等待读取n个字节长的<code>unstructured data</code>，n由<code>text line</code>中的bytes指定。读完之后，<code>conn_nread</code>--&gt;<code>conn_write</code>，向客户端发送一行回复信息。最后conn再次变为<code>conn_read</code>等待命令输入。</p>
<ul>
<li><code>get &lt;key&gt;*\r\n</code></li>
</ul>
<p>get命令只有一个<code>text line</code>，后面可以有多个key。当memcached读完这条命令后，<code>conn_read</code>--&gt;<code>conn_mwrite</code>，返回多个items。</p>
<h3>hashtable</h3>
<p>memcached的hashtable是大小为<code>2**20</code>的<code>item *</code>的数组。至于hash函数的算法就略过了，它共定义了3个API：</p>
<ul>
<li><code>item *assoc_find(char *key)</code></li>
<li><code>int assoc_insert(char *key, item *it)</code></li>
<li><code>void assoc_delete(char *key)</code></li>
</ul>
<p>顾名思义。</p>
<h3>内存分配</h3>
<p><em>Not Implement</em></p>
<h3>I/O</h3>
<p>memcached支持TCP，UDP，UNIX socket，读直接使用read(2)，写使用sendmsg(2)，并且<code>struct iovec</code>是动态分配，保存在<code>conn</code>结构中。</p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/git-proxy/" class="u-url">git proxy</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Tao Qingyun
            </span></p>
            <p class="dateline"><a href="posts/git-proxy/" rel="bookmark"><time class="published dt-published" datetime="2016-08-06T14:38:12+08:00" title="2016-08-06 14:38">2016-08-06 14:38</time></a></p>
                <p class="commentline">
        
    <a href="posts/git-proxy/#disqus_thread" data-disqus-identifier="cache/posts/git-proxy.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>Git支持多种传输协议，ssh、git、HTTP(S)，甚至ftp，rsync。</p>
<p>当使用不同传输方式时，设置代理的方式也不同。</p>
<h3>SSH</h3>
<p>当使用SSH协议时，git实际上直接使用ssh命令，所以我们只要给ssh设置好代理就可以了。在~/.ssh/config中：</p>
<pre class="code literal-block"><span></span>Host github.com
    User                    git
    ProxyCommand            nc -x localhost:1080 %h %p
</pre>


<p>参见ssh_config(5)manual</p>
<h3>HTTP(S)</h3>
<p>git使用<code>libcurl</code>来处理HTTP和HTTPS，可以通过设置git的<code>http.proxy</code>选项：</p>
<p><code>git config --global http.proxy socks5://localhost:1080</code></p>
<p>也可以直接设置curl支持的环境变量，比如<code>ALL_PROXY=socks5://localhost:1080</code></p>
<p>参见curl(1)的--proxy选项和git-config(1)中的http.proxy</p>
<h3>Git</h3>
<p>当使用git传输协议时，你可以设置git的<code>gitproxy</code>选项：</p>
<p><code>git config --global core.gitproxy git-proxy</code></p>
<p>这里的git-proxy是任何一个可执行文件，同时它要能接受2个参数，host、port（git服务器的地址和端口）。git-proxy完成代理工作。</p>
<p>例如这样一个shell脚本：</p>
<pre class="code literal-block"><span></span><span class="ch">#!/usr/bin/env bash</span>

nc -x localhost:1080 <span class="nv">$1</span> <span class="nv">$2</span>
</pre>


<p>也可以直接设置环境变量<code>GIT_PROXY_COMMAND=git-porxy</code></p>
<p>参见git_config(1)</p>
<h3>如何判断git使用何种协议</h3>
<p>根据git服务器的url就可以看出：</p>
<ul>
<li>ssh://[user@]host.xz[:port]/path/to/repo.git/</li>
<li>git://host.xz[:port]/path/to/repo.git/</li>
<li>http[s]://host.xz[:port]/path/to/repo.git/</li>
<li>ftp[s]://host.xz[:port]/path/to/repo.git/</li>
<li>rsync://host.xz/path/to/repo.git/</li>
</ul>
<p>对于SSH协议，还有一种类似scp的语法：</p>
<ul>
<li>[user@]host.xz:path/to/repo.git/</li>
</ul>
<p>参见git-fetch(1)的GIT URLS</p>
<h3>nc命令</h3>
<p>nc(netcat)可以用 -X 指定代理方式：socks4、 sockes5、 HTTPS CONNECT，默认为socks5。 -x 指定代理地址。</p>
<p>参见nc(1)</p>
<h3>example</h3>
<p>golang的<code>go get</code>命令会用到git，你可以这样：</p>
<p><code>env ALL_PROXY=socks5://localhost:1080 GIT_PROXY_COMMAND=git-porxy go get -v ./...</code></p>
<h3>reference</h3>
<p><a href="http://cms-sw.github.io/tutorial-proxy.html">Tutorial: how to use git through a proxy</a></p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/python-logging/" class="u-url">python logging</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Tao Qingyun
            </span></p>
            <p class="dateline"><a href="posts/python-logging/" rel="bookmark"><time class="published dt-published" datetime="2016-07-09T21:32:25+08:00" title="2016-07-09 21:32">2016-07-09 21:32</time></a></p>
                <p class="commentline">
        
    <a href="posts/python-logging/#disqus_thread" data-disqus-identifier="cache/posts/python-logging.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>日志对程序的调试和问题的发现很有帮助。如何设置合适的日志需要需要一些考虑。</p>
<p>以python2.7标准库logging为例。</p>
<p>logging分有多种级别:</p>
<ul>
<li>NOTSET</li>
<li>DEBUG</li>
<li>INFO</li>
<li>WARNING</li>
<li>ERROR</li>
<li>CRITICAL</li>
</ul>
<p>一个应用中可以有多个logger对象，比如每个module一个logger。
不同logger对象可以设置不同的级别，只有大于该级别的log事件才会被记录。</p>
<p>log的记录和处理是分开的，你可以把log简单的打印出来，写到文件中，甚至遇到高级别log事件时，直接给你发邮件。这是由<code>logging.Handler</code>对象来处理，你可以为一个logger添加多个handler，同时handler也是分级别的，这样你就可以对不同级别的log做出不同的处理了。</p>
<p>每个Logger都有一个唯一的名字，通常用<code>logging.getLogger(__name__)</code>，这样得到的logger的名字就是当前模块的名字,这样还有一个好处，logger是分层的，比如<code>input</code>logger就是<code>input.cvs</code>，<code>input.xls</code>logger的上层。这与python的模块命名空间一致，以<code>.</code>做分割。</p>
<p>这里的分层还意味着log事件会向上层传递，当然你也可以阻止这个行为，通过设置<code>Logger.propagate</code>为False。</p>
<p>logger，handler，formmater(log的格式)的创建，配置可以直接写在代码中，比如：</p>
<pre class="code literal-block"><span></span><span class="kn">import</span> <span class="nn">logging</span>

<span class="c1"># create logger</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">'simple_example'</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

<span class="c1"># create console handler and set level to debug</span>
<span class="n">ch</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
<span class="n">ch</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

<span class="c1"># create formatter</span>
<span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">'</span><span class="si">%(asctime)s</span><span class="s1"> - </span><span class="si">%(name)s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">'</span><span class="p">)</span>

<span class="c1"># add formatter to ch</span>
<span class="n">ch</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>

<span class="c1"># add ch to logger</span>
<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

<span class="c1"># 'application' code</span>
<span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'debug message'</span><span class="p">)</span>
</pre>


<p>logging模块也提供了从配置文件设置的方法，使用函数<code>fileConfig()</code>：</p>
<pre class="code literal-block"><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">logging.config</span>

<span class="n">logging</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">fileConfig</span><span class="p">(</span><span class="s1">'logging.conf'</span><span class="p">)</span>

<span class="c1"># create logger</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">'simpleExample'</span><span class="p">)</span>

<span class="c1"># 'application' code</span>
<span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'debug message'</span><span class="p">)</span>
</pre>


<p>相应的配置文件如下：</p>
<pre class="code literal-block"><span></span><span class="k">[loggers]</span>
<span class="na">keys</span><span class="o">=</span><span class="s">root,simpleExample</span>

<span class="k">[handlers]</span>
<span class="na">keys</span><span class="o">=</span><span class="s">consoleHandler</span>

<span class="k">[formatters]</span>
<span class="na">keys</span><span class="o">=</span><span class="s">simpleFormatter</span>

<span class="k">[logger_root]</span>
<span class="na">level</span><span class="o">=</span><span class="s">DEBUG</span>
<span class="na">handlers</span><span class="o">=</span><span class="s">consoleHandler</span>

<span class="k">[logger_simpleExample]</span>
<span class="na">level</span><span class="o">=</span><span class="s">DEBUG</span>
<span class="na">handlers</span><span class="o">=</span><span class="s">consoleHandler</span>
<span class="na">qualname</span><span class="o">=</span><span class="s">simpleExample</span>
<span class="na">propagate</span><span class="o">=</span><span class="s">0</span>

<span class="k">[handler_consoleHandler]</span>
<span class="na">class</span><span class="o">=</span><span class="s">StreamHandler</span>
<span class="na">level</span><span class="o">=</span><span class="s">DEBUG</span>
<span class="na">formatter</span><span class="o">=</span><span class="s">simpleFormatter</span>
<span class="na">args</span><span class="o">=</span><span class="s">(sys.stdout,)</span>

<span class="k">[formatter_simpleFormatter]</span>
<span class="na">format</span><span class="o">=</span><span class="s">%(asctime)s - %(name)s - %(levelname)s - %(message)s</span>
<span class="na">datefmt</span><span class="o">=</span>
</pre>


<p>这种方式的好处是把代码与配置分开。logging还提供了第三种方式，<code>dictConfig()</code>,它通过python的<code>dict</code>对象来配置。这比第二种方式更进一步，你可以用任何一种配置文件格式，再把它转成符合一定规范的<code>dict</code>就可以了。</p>
<h3>reference</h3>
<p><a href="https://docs.python.org/2/howto/logging.html">Logging HOWTO</a></p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/crawler/" class="u-url">A Web Crawler With asyncio Coroutines</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Tao Qingyun
            </span></p>
            <p class="dateline"><a href="posts/crawler/" rel="bookmark"><time class="published dt-published" datetime="2016-07-09T11:32:25+08:00" title="2016-07-09 11:32">2016-07-09 11:32</time></a></p>
                <p class="commentline">
        
    <a href="posts/crawler/#disqus_thread" data-disqus-identifier="cache/posts/crawler.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<h3>Introduction</h3>
<p>经典的计算机科学强调高效的算法，尽可能快地完成计算。但是很多网络程序的时间并不是消耗在计算上，而是在等待许多慢速的连接或者低频事件的发生。这些程序暴露出一个新的挑战：如何高效的等待大量网络事件。一个现代的解决方案是异步I/O。</p>
<p>这一章我们将实现一个简单的网络爬虫。这个爬虫只是一个原型式的异步应用，因为它等待许多响应而只做少量的计算。一次爬的网页越多，它就能越快的完成任务。如果它为每个动态的请求启动一个线程的话，随着并发请求数量的增加，它会在耗尽套接字之前，耗尽内存或者线程相关的资源。使用异步I/O可以避免这个的问题。</p>
<p>我们将分三个阶段展示这个例子。首先，我们会实现一个事件循环并用这个事件循环和回调来勾画出一个网络爬虫。它很有效，但是当把它扩展成更复杂的问题时，就会导致无法管理的混乱代码。然后，由于Python的协程不仅有效而且可扩展，我们将用Python的生成器函数实现一个简单的协程。在最后一个阶段，我们将使用Python标准库"asyncio"中功能完整的协程和异步队列完成这个网络爬虫。</p>
<h3>The Task</h3>
<p>网络爬虫寻找并下载一个网站上的所有网页，也许还会把它们存档，为它们建立索引。从根URL开始，它获取每个网页，解析出没有遇到过的链接加到队列中。当网页没有未见到过的链接并且队列为空时，它便停止运行。</p>
<p>我们可以通过同时下载大量的网页来加快这一过程。当爬虫发现新的链接，它使用一个新的套接字并行的处理这个新链接，解析响应，添加新链接到队列。当并发很大时，可能会导致性能下降，所以我们会限制并发的数量，在队列保留那些未处理的链接，直到一些正在执行的任务完成。</p>
<h3>The Traditional Approach</h3>
<p>怎么使一个爬虫并发？传统的做法是创建一个线程池，每个线程使用一个套接字在一段时间内负责一个网页的下载。比如，下载xkcd.com网站的一个网页：</p>
<pre class="code literal-block"><span></span><span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">'xkcd.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="n">request</span> <span class="o">=</span> <span class="s1">'GET {} HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: xkcd.com</span><span class="se">\r\n\r\n</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">'ascii'</span><span class="p">))</span>
    <span class="n">response</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">''</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>

    <span class="c1"># Page is now downloaded.</span>
    <span class="n">links</span> <span class="o">=</span> <span class="n">parse_links</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
    <span class="n">q</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
</pre>


<p>套接字操作默认是阻塞的：当一个线程调用一个类似<code>connect</code>和<code>recv</code>方法时，它会阻塞，直到操作完成.<sup id="fnref-15"><a class="footnote-ref" href="posts/crawler/#fn-15">13</a></sup>因此，为了同一时间内下载多个网页，我们需要很多线程。一个复杂的应用会通过线程池保持空闲的线程来分摊创建线程的开销。同样的做法也适用于套接字，使用连接池。</p>
<p>到目前为止，线程是昂贵的，操作系统对一个进程，一个用户，一台机器能使用线程做了不同的硬性限制。在Jesse系统中，一个Python线程需要50K的内存，开启上万个线程会失败。每个线程的开销和系统的限制就是这种方式的瓶颈所在。</p>
<p>在Dan Kegel那一篇很有影响力的文章"The C10K problem"<sup id="fnref-8"><a class="footnote-ref" href="posts/crawler/#fn-8">5</a></sup>中，它提出多线程方式在I/O并发上的局限性。他在开始写道，</p>
<blockquote>
<p>是时候网络服务器要同时处理成千上万的客户啦，你不这样认为么？毕竟，现在网络是个很大的地方。</p>
</blockquote>
<p>Kegel在1999年创造出"C10K"术语。一万个连接在今天看来还是可接受的，但是问题依然存在，只不过大小不同。回到那时候，对于C10K问题，每个连接启一个线程是不切实际的。现在这个限制已经成指数级增长。确实，我们的玩具网络爬虫使用线程也可以工作的很好。但是，对于有着千万级连接的大规模应用来说，限制依然存在：会消耗掉所有线程，即使套接字还够用。那么我们该如何解决这个问题？</p>
<h3>Async</h3>
<p>异步I/O框架在一个线程中完成并发操作。让我们看看这是怎么做到的。</p>
<p>异步框架使用<em>非阻塞</em>套接字。异步爬虫中，我们在发起到服务器的连接前把套接字设为非阻塞：</p>
<pre class="code literal-block"><span></span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">'xkcd.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="k">except</span> <span class="n">BlockingIOError</span><span class="p">:</span>
    <span class="k">pass</span>
</pre>


<p>对一个非阻塞套接字调用<code>connect</code>方法会立即抛出异常，即使它正常工作。这个异常模拟了底层C语言函数的行为，它把<code>errno</code>设置为<code>EINPROGRESS</code>,告诉你操作已经开始。</p>
<p>现在我们的爬虫需要一种知道连接何时建立的方法，这样它才能发送HTTP请求。我们可以简单地使用循环来重试：</p>
<pre class="code literal-block"><span></span><span class="n">request</span> <span class="o">=</span> <span class="s1">'GET {} HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: xkcd.com</span><span class="se">\r\n\r\n</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="n">encoded</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">'ascii'</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">encoded</span><span class="p">)</span>
        <span class="k">break</span>  <span class="c1"># Done.</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="k">print</span><span class="p">(</span><span class="s1">'sent'</span><span class="p">)</span>
</pre>


<p>这种方法不仅消耗CPU，也不能有效的等待<em>多个</em>套接字。在远古时代，BSD Unix的解决方法是<code>select</code>,一个C函数，它在一个或一组非阻塞套接字上等待事件发生。现在，互联网应用大量连接的需求，导致<code>select</code>被<code>poll</code>代替，以及BSD的<code>kqueue</code>和Linux的<code>epoll</code>。它们的API和<code>select</code>相似，但在大数量的连接中也能有较好的性能。</p>
<p>Python 3.4的<code>DefaultSelector</code>使用你系统上最好的类<code>select</code>函数。去注册一个网络I/O事件，我们创建一个非阻塞套接字，并使用默认的selector注册。</p>
<pre class="code literal-block"><span></span><span class="kn">from</span> <span class="nn">selectors</span> <span class="kn">import</span> <span class="n">DefaultSelector</span><span class="p">,</span> <span class="n">EVENT_WRITE</span>

<span class="n">selector</span> <span class="o">=</span> <span class="n">DefaultSelector</span><span class="p">()</span>

<span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">'xkcd.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="k">except</span> <span class="n">BlockingIOError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">connected</span><span class="p">():</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'connected!'</span><span class="p">)</span>

<span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_WRITE</span><span class="p">,</span> <span class="n">connected</span><span class="p">)</span>
</pre>


<p>我们不理会这个伪造的错误，调用<code>selector.register</code>，传递套接字文件描述符，一个表示我们想要监听什么事件的常量。为了当连接建立时收到提醒，我们使用<code>EVENT_WRITE</code>:它表示什么时候这个套接字可写。我们还传递了一个Python函数，<code>connected</code>,当对应事件发生时被调用。这样的函数被称为<em>回调</em>。</p>
<p>我们在一个循环中处理I/O提醒，随着selector接收到它们。</p>
<pre class="code literal-block"><span></span><span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">event_key</span><span class="o">.</span><span class="n">data</span>
            <span class="n">callback</span><span class="p">()</span>
</pre>


<p><code>connected</code>回调函数被保存在<code>event_key.data</code>中，一旦这个非阻塞套接字建立连接，它就会被取出来执行。</p>
<p>不像我们前面那个快速重试的循环，这里的<code>select</code>调用会阻塞，等待下一个I/O事件，接着执行等待这个事件的回调函数。</p>
<p>到目前为止我们展现了什么？我们展示了如何开始一个I/O操作和当操作准备好时调用回调函数。异步<em>框架</em>，它在单线程中执行并发操作，建立在两个功能之上，非阻塞套接字和事件循环。</p>
<h3>Programming With Callbacks</h3>
<p>用我们刚刚建立的异步框架，怎么才能完成一个网络爬虫？即使是一个简单的网页下载程序也是很难写的。</p>
<p>首先，我们有一个未获取的URL集合，和一个已经解析过的URL集合。</p>
<pre class="code literal-block"><span></span><span class="n">urls_todo</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">'/'</span><span class="p">])</span>
<span class="n">seen_urls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">'/'</span><span class="p">])</span>
</pre>


<p>这两个集合加在一起就是所有的URL。用"/"初始化它们。</p>
<p>获取一个网页需要一系列的回调。在套接字连接建立时<code>connected</code>回调触发，它向服务器发送一个GET请求。但是它要等待响应，所以我们需要注册另一个回调函数，当回调被调用，它也不能一次读取完整的请求，所以，需要再一次注册，如此反复。</p>
<p>让我们把这些回调放在一个<code>Fetcher</code>对象中，它需要一个URL，一个套接字，还需要一个地方保存返回的字节：</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Fetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">''</span>  <span class="c1"># Empty array of bytes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="bp">None</span>
</pre>


<p>我们的入口点在<code>Fetcher.fetch</code>:</p>
<pre class="code literal-block"><span></span>    <span class="c1"># Method on Fetcher class.</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">'xkcd.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">BlockingIOError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Register next callback.</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                          <span class="n">EVENT_WRITE</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">)</span>
</pre>


<p><code>fetch</code>方法从连接一个套接字开始。但是要注意这个方法在连接建立前就返回了。它必须返回到事件循环中等待连接建立。为了理解为什么要要这样，假设我们程序的整体结构如下：</p>
<pre class="code literal-block"><span></span><span class="c1"># Begin fetching http://xkcd.com/353/</span>
<span class="n">fetcher</span> <span class="o">=</span> <span class="n">Fetcher</span><span class="p">(</span><span class="s1">'/353/'</span><span class="p">)</span>
<span class="n">fetcher</span><span class="o">.</span><span class="n">fetch</span><span class="p">()</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="n">callback</span> <span class="o">=</span> <span class="n">event_key</span><span class="o">.</span><span class="n">data</span>
        <span class="n">callback</span><span class="p">(</span><span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span><span class="p">)</span>
</pre>


<p>所有的事件提醒都在事件循环中的<code>select</code>函数后处理。所以<code>fetch</code>必须把控制权交给事件循环。这样我们的程序才能知道什么时候连接已建立，接着循环调用<code>connected</code>回调，它已经在<code>fetch</code>方法中注册过。</p>
<p>这里是我们<code>connected</code>方法的实现：</p>
<pre class="code literal-block"><span></span>    <span class="c1"># Method on Fetcher class.</span>
    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'connected!'</span><span class="p">)</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>
        <span class="n">request</span> <span class="o">=</span> <span class="s1">'GET {} HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: xkcd.com</span><span class="se">\r\n\r\n</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">'ascii'</span><span class="p">))</span>

        <span class="c1"># Register the next callback.</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span>
                          <span class="n">EVENT_READ</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">read_response</span><span class="p">)</span>
</pre>


<p>这个方法发送一个GET请求。一个真正的应用会检查<code>send</code>的返回值，以防所有的信息没能一次发送出去。但是我们的请求很小，应用也不复杂。它只是简单的调用<code>send</code>，然后等待响应。当然，它必须注册另一个回调并把控制权交给事件循环。接下来也是最后一个回调函数<code>read_response</code>，它处理服务器的响应：</p>
<pre class="code literal-block"><span></span>    <span class="c1"># Method on Fetcher class.</span>
    <span class="k">def</span> <span class="nf">read_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">stopped</span>

        <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>  <span class="c1"># 4k chunk size.</span>
        <span class="k">if</span> <span class="n">chunk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>  <span class="c1"># Done reading.</span>
            <span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_links</span><span class="p">()</span>

            <span class="c1"># Python set-logic:</span>
            <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">seen_urls</span><span class="p">):</span>
                <span class="n">urls_todo</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
                <span class="n">Fetcher</span><span class="p">(</span><span class="n">link</span><span class="p">)</span><span class="o">.</span><span class="n">fetch</span><span class="p">()</span>  <span class="c1"># &lt;- New Fetcher.</span>

            <span class="n">seen_urls</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
            <span class="n">urls_todo</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">urls_todo</span><span class="p">:</span>
                <span class="n">stopped</span> <span class="o">=</span> <span class="bp">True</span>
</pre>


<p>这个回调在每次selector发现套接字<em>可读</em>时被调用，可读有两种情况：套接字接受到数据或它被关闭。</p>
<p>这个回调函数从套接字读取4K数据。如果没有4k，那么有多少读多少。如果比4K多，<code>chunk</code>只包4K数据并且这个套接字保持可读，这样在事件循环的下一个周期，会在次回到这个回调函数。当响应完成时，服务器关闭这个套接字，<code>chunk</code>为空。</p>
<p>没有展示的<code>parse_links</code>方法，它返回一个URL集合。我们为每个新的URL启动一个fetcher。注意一个使用异步回调方式编程的好处：我们不需要为共享数据加锁，比如我们往<code>seen_urls</code>增加新链接时。这是一种非抢占式的多任务，它不会在我们代码中的任意一个地方中断。</p>
<p>我们增加了一个全局变量<code>stopped</code>，用它来控制这个循环：</p>
<pre class="code literal-block"><span></span><span class="n">stopped</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stopped</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">event_key</span><span class="o">.</span><span class="n">data</span>
            <span class="n">callback</span><span class="p">()</span>
</pre>


<p>一旦所有的网页被下载下来，fetcher停止这个事件循环，程序退出。</p>
<p>这个例子让异步编程的一个问题明显的暴露出来：意大利面代码。</p>
<p>我们需要某种方式来表达一串计算和I/O操作，并且能够调度多个这样的操作让他们并发的执行。但是，没有线程你不能把这一串操作写在一个函数中：当函数开始一个I/O操作，它明确的把未来所需的状态保存下来，然后返回。你需要考虑如何写这个状态保存的代码。</p>
<p>让我们来解释下这到底是什么意思。考虑在线程中使用通常的阻塞套接字来获取一个网页时是多么简单。</p>
<pre class="code literal-block"><span></span><span class="c1"># Blocking version.</span>
<span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">'xkcd.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="n">request</span> <span class="o">=</span> <span class="s1">'GET {} HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: xkcd.com</span><span class="se">\r\n\r\n</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">'ascii'</span><span class="p">))</span>
    <span class="n">response</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">''</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>

    <span class="c1"># Page is now downloaded.</span>
    <span class="n">links</span> <span class="o">=</span> <span class="n">parse_links</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
    <span class="n">q</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
</pre>


<p>在一个套接字操作和下一个操作之间这个函数到底记住了什么？它有一个套接字，一个URL和一个可增长的<code>response</code>。运行在线程中的函数使用编程语言的基本功能，栈中的局部变量来保存临时的状态。这样的函数有一个"continuation"----在I/O结束后它要执行的代码。运行时通过线程的指令指针来记住这个continuation。你不必考虑怎么在I/O操作后恢复局部变量和这个continuation。语言本身的特性帮你解决。</p>
<p>但是用一个基于回调的异步框架，这些语言特性不能提供一点帮助。当等待I/O操作时，一个函数必须明确的保存它的状态，因为它会在I/O操作完成之前返回并清除栈帧。为了在我们基于回调的例子中代替局部变量，我们把<code>sock</code>和<code>response</code>作为Fetcher实例<code>self</code>属性。为了代替指令指针，它通过注册<code>connnected</code>和<code>read_response</code>回调来保存continuation。随着应用功能的增长，我们手动保存回调的复杂性也会增加。如此繁复的记账式工作会让编码者感到头痛。</p>
<p>更糟糕的是，当我们的回调函数抛出异常会发生什么？假设我们没有写好<code>parse_links</code>方法，它在解析HTML时抛出异常：</p>
<pre class="code literal-block"><span></span>Traceback (most recent call last):
  File "loop-with-callbacks.py", line 111, in &lt;module&gt;
    loop()
  File "loop-with-callbacks.py", line 106, in loop
    callback(event_key, event_mask)
  File "loop-with-callbacks.py", line 51, in read_response
    links = self.parse_links()
  File "loop-with-callbacks.py", line 67, in parse_links
    raise Exception('parse error')
Exception: parse error
</pre>


<p>这个堆栈回溯只能显示出事件循环调用了一个回调。我们不知道是什么导致了这个错误。这条链的两边都被破坏：不知道从哪来也不知到哪去。这种丢失上下文的现象被称为"stack ripping"，它还会阻止我们为回调链设置异常处理。</p>
<p>所以，除了关于多线程和异步那个更高效的争议，还有一个关于这两者之间的争论，谁更容易出错。如果在同步上出现失误，线程更容易出现数据竞争的问题，而回调因为"stack ripping"问题而非常难于调试。</p>
<h3>Coroutines</h3>
<p>还记得我们对你许下的承诺么？我们可以写出这样的异步代码，它既有回调方式的高效，也有多线程代码的简洁。这个结合是同过一种称为协程的模式来实现的。使用Python3.4标准库asyncio和一个叫"aiohttp"的包，在协程中获取一个网页是非常直接的<sup id="fnref-10"><a class="footnote-ref" href="posts/crawler/#fn-10">7</a></sup>：</p>
<pre class="code literal-block"><span></span>    <span class="nd">@asyncio.coroutine</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="n">response</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">body</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre>


<p>它也是可扩展的。在Jesse系统上，与每个线程50k内存相比，一个Python协程只需要3k内存。Python很容易就可以启动上千个协程。</p>
<p>协程的概念可以追溯到计算机科学的远古时代，它很简单，一个可以暂停和恢复的子过程。线程是被操作系统控制的抢占式多任务，而协程是可合作的，它们自己选择什么时候暂停去执行下一个协程。</p>
<p>有很多协程的实现。甚至在Python中也有几种。Python3.4标准库asyncio中的协程，它是建立在生成器，一个Future类和"yield from"语句之上。从Python3.5开始，协程变成了语言本身的特性。然而，理解Python3.4中这个通过语言原有功能实现的协程，是我们处理Python3.5中原生协程的基础。</p>
<h3>How Python Generators Work</h3>
<p>在你理解生成器之前，你需要知道普通的Python函数是怎么工作的。当一个函数调用一个子过程，这个被调用函数获得控制权。直到它返回或者有异常发生，才把控制权交给调用者：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">bar</span><span class="p">()</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">pass</span>
</pre>


<p>标准的Python解释器是C语言写的。一个Python函数被调用对应的C函数是<code>PyEval_EvalFrameEx</code>。它获得一个Python栈帧结构并在这个栈帧的上下文中执行Python字节码。这里是<code>foo</code>的字节码：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">dis</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
  <span class="mi">2</span>           <span class="mi">0</span> <span class="n">LOAD_GLOBAL</span>              <span class="mi">0</span> <span class="p">(</span><span class="n">bar</span><span class="p">)</span>
              <span class="mi">3</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">0</span> <span class="p">(</span><span class="mi">0</span> <span class="n">positional</span><span class="p">,</span> <span class="mi">0</span> <span class="n">keyword</span> <span class="n">pair</span><span class="p">)</span>
              <span class="mi">6</span> <span class="n">POP_TOP</span>
              <span class="mi">7</span> <span class="n">LOAD_CONST</span>               <span class="mi">0</span> <span class="p">(</span><span class="bp">None</span><span class="p">)</span>
             <span class="mi">10</span> <span class="n">RETURN_VALUE</span>
</pre>


<p><code>foo</code>函数在它栈中加载<code>bar</code>并调用它，然后把<code>bar</code>的返回值从栈中弹出，加载<code>None</code>值并返回。</p>
<p>当<code>PyEval_EvalFrameEx</code>遇到<code>CALL_FUNCTION</code>字节码时，它会创建一个新的栈帧，并用这个栈帧递归的调用<code>PyEval_EvalFrameEx</code>来执行<code>bar</code>函数。</p>
<p>图</p>
<p>非常重要的一点是，Python的栈帧在堆中分配！Python解释器是一个标准的C程序，所以他的栈帧是正常的栈帧。但是Python的栈帧是在堆中处理。这意味着Python栈帧在函数调用结束后依然可以存在。我们在<code>bar</code>函数中保存当前的栈帧，交互式的看看这种现象：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">inspect</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">frame</span> <span class="o">=</span> <span class="bp">None</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">bar</span><span class="p">()</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">global</span> <span class="n">frame</span>
<span class="o">...</span>     <span class="n">frame</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">foo</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># The frame was executing the code for 'bar'.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
<span class="s1">'bar'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># Its back pointer refers to the frame for 'foo'.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller_frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_back</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller_frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>
<span class="s1">'foo'</span>
</pre>


<p>现在该说Python生成器了，它使用同样构件--code object和栈帧--去完成一个不可思议的任务。</p>
<p>这是一个生成器函数：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s1">'result of yield: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
<span class="o">...</span>     <span class="n">result2</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">2</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s1">'result of 2nd yield: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result2</span><span class="p">))</span>
<span class="o">...</span>     <span class="k">return</span> <span class="s1">'done'</span>
<span class="o">...</span>     
</pre>


<p>在Python把<code>gen_fn</code>编译成字节码的过程中，一旦它看到<code>yield</code>语句就知道这是一个生成器函数而不是普通的函数。它就会设置一个标志来记住这个事实：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="c1"># The generator flag is bit position 5.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">generator_bit</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bool</span><span class="p">(</span><span class="n">gen_fn</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_flags</span> <span class="o">&amp;</span> <span class="n">generator_bit</span><span class="p">)</span>
<span class="bp">True</span>
</pre>


<p>当你调用一个生成器函数，Python看到这个标志，就不会运行它而是创建一个生成器：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span> <span class="o">=</span> <span class="n">gen_fn</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">type</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="err">'</span><span class="nc">generator</span><span class="s1">'&gt;</span>
</pre>


<p>Python生成器封装了一个栈帧和函数体代码：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_code</span><span class="o">.</span><span class="n">co_name</span>
<span class="s1">'gen_fn'</span>
</pre>


<p>所有通过调用<code>gen_fn</code>的生成器指向同一段代码，但都有各自的栈帧。这些栈帧不再任何一个C函数栈中，而是在堆空间中等待被使用：</p>
<p>图</p>
<p>栈帧中有一个指向最后执行指令的指针。初始化为-1，意味着它没开始运行：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>
<span class="o">-</span><span class="mi">1</span>
</pre>


<p>当我们调用<code>send</code>时，生成器一直运行到第一个<code>yield</code>语句处停止。并且<code>send</code>返回1，yield语句后的表达式的值。</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="mi">1</span>
</pre>


<p>现在生成器的指令指针是3，字节码一共有56个字节：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>
<span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">gi_code</span><span class="o">.</span><span class="n">co_code</span><span class="p">)</span>
<span class="mi">56</span>
</pre>


<p>这个生成器可以在任何时候，任何函数中恢复运行，因为它的栈帧并不在真正的栈中，而是堆中。在调用链中它的位置也是不确定的，它不必遵循普通函数先进后出的顺序。它像云一样自由。</p>
<p>我们可以传递一个<code>hello</code>给生成器，它会成为yield语句的结果，并且生成器运行到第二个yield语句处。</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">)</span>
<span class="n">result</span> <span class="n">of</span> <span class="k">yield</span><span class="p">:</span> <span class="n">hello</span>
<span class="mi">2</span>
</pre>


<p>现在栈帧中包含局部变量<code>result</code>:</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_locals</span>
<span class="p">{</span><span class="s1">'result'</span><span class="p">:</span> <span class="s1">'hello'</span><span class="p">}</span>
</pre>


<p>其它从<code>gen_fn</code>创建的生成器有着它自己的栈帧和局部变量。</p>
<p>当我们在一次调用<code>send</code>，生成器从第二个yield开始运行，以抛出一个特殊的<code>StopIteration</code>异常为结束。</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">'goodbye'</span><span class="p">)</span>
<span class="n">result</span> <span class="n">of</span> <span class="mi">2</span><span class="n">nd</span> <span class="k">yield</span><span class="p">:</span> <span class="n">goodbye</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">StopIteration</span><span class="p">:</span> <span class="n">done</span>
</pre>


<p>这个异常有一个值"done"，它就是生成器的返回值。</p>
<h3>Building Coroutines With Generators</h3>
<p>所以生成器可以暂停，可以给它一个值让它恢复，并且它还有一个返回值。这些特性看起来很适合去建立一个不使用回调的异步编程模型。我们想创造一个协程：一个在程序中可以和其他过程合作调度的过程。我们的协程将会是标准库<code>asyncio</code>中协程的一个简化版本，我们将使用生成器，futures和<code>yield from</code>语句。</p>
<p>首先，我们需要一种方法去代表协程需要等待的未来事件。一个简化的版本是：</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Future</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre>


<p>一个future初始化为未解决的，它同过调用<code>set_result</code>来解决。<sup id="fnref-12"><a class="footnote-ref" href="posts/crawler/#fn-12">10</a></sup></p>
<p>让我们用futures和协程来改写我们的fetcher。我们之前用回调写的fetcher如下：</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Fetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">'xkcd.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">BlockingIOError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                          <span class="n">EVENT_WRITE</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'connected!'</span><span class="p">)</span>
        <span class="c1"># And so on....</span>
</pre>


<p><code>fetch</code>方法开始连接一个套接字，然后注册<code>connected</code>回调函数，它会在套接字建立连接后调用。现在我们使用协程把这两步合并：</p>
<pre class="code literal-block"><span></span>    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">'xkcd.com'</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">BlockingIOError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">on_connected</span><span class="p">():</span>
            <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                          <span class="n">EVENT_WRITE</span><span class="p">,</span>
                          <span class="n">on_connected</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">f</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'connected!'</span><span class="p">)</span>
</pre>


<p>现在，<code>fetch</code>是一个生成器，因为他有一个<code>yield</code>语句。我们创建一个未决的future，然后yield它，暂停执行直到套接字连接建立。内函数<code>on_connected</code>解决这个future。</p>
<p>但是当future被解决，谁来恢复这个生成器？我们需要一个协程驱动器。让我们叫它<code>task</code>:</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Task</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coro</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">next_future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

<span class="c1"># Begin fetching http://xkcd.com/353/</span>
<span class="n">fetcher</span> <span class="o">=</span> <span class="n">Fetcher</span><span class="p">(</span><span class="s1">'/353/'</span><span class="p">)</span>
<span class="n">Task</span><span class="p">(</span><span class="n">fetcher</span><span class="o">.</span><span class="n">fetch</span><span class="p">())</span>

<span class="n">loop</span><span class="p">()</span>
</pre>


<p>task通过传递一个None值给<code>fetch</code>来启动它。<code>fetch</code>运行到它yeild一个future，这个future被task捕获作为<code>next_future</code>。当套接字连接建立，事件循环运行回调函数<code>on_connected</code>，这里future被解决，<code>step</code>被调用，生成器恢复运行。</p>
<h3>Factoring Coroutines With <code>yield from</code>
</h3>
<p>一旦套接字连接建立，我们就可以发送HTTP请求，然后读取服务器响应。不再需要哪些分散在各处的回调函数，我们把它们放在同一个生成器函数中：</p>
<pre class="code literal-block"><span></span>    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ... connection logic from above, then:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">'ascii'</span><span class="p">))</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">on_readable</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">))</span>

            <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span>
                              <span class="n">EVENT_READ</span><span class="p">,</span>
                              <span class="n">on_readable</span><span class="p">)</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">f</span>
            <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chunk</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Done reading.</span>
                <span class="k">break</span>
</pre>


<p>从套接字中读取所有信息的代码看起来很通用。我们能不把它提取成一个子过程？现在该Python3的<code>yield from</code>登场了。它能让一个生成器委托另一个生成器。</p>
<p>让我们先回到原来那个简单的生成器：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s1">'result of yield: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
<span class="o">...</span>     <span class="n">result2</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">2</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s1">'result of 2nd yield: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result2</span><span class="p">))</span>
<span class="o">...</span>     <span class="k">return</span> <span class="s1">'done'</span>
<span class="o">...</span>     
</pre>


<p>为了从其他生成器调用这个生成器，我们使用<code>yield from</code>:</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="c1"># Generator function:</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">caller_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">gen</span> <span class="o">=</span> <span class="n">gen_fn</span><span class="p">()</span>
<span class="o">...</span>     <span class="n">rv</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">gen</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="s1">'return value of yield-from: {}'</span>
<span class="o">...</span>           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rv</span><span class="p">))</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># Make a generator from the</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># generator function.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span> <span class="o">=</span> <span class="n">caller_fn</span><span class="p">()</span>
</pre>


<p>这个<code>caller</code>的行为的和它委派的生成器表现的完全一致：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>
<span class="mi">15</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">)</span>
<span class="n">result</span> <span class="n">of</span> <span class="k">yield</span><span class="p">:</span> <span class="n">hello</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">gi_frame</span><span class="o">.</span><span class="n">f_lasti</span>  <span class="c1"># Hasn't advanced.</span>
<span class="mi">15</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">'goodbye'</span><span class="p">)</span>
<span class="n">result</span> <span class="n">of</span> <span class="mi">2</span><span class="n">nd</span> <span class="k">yield</span><span class="p">:</span> <span class="n">goodbye</span>
<span class="k">return</span> <span class="n">value</span> <span class="n">of</span> <span class="k">yield</span><span class="o">-</span><span class="n">from</span><span class="p">:</span> <span class="n">done</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="ne">StopIteration</span>
</pre>


<p>注意到<code>caller</code>的指令指针保持15不变，就是<code>yield from</code>的地方，即使内部的生成器从一个yield语句运行到下一个yield，它始终不变。<sup id="fnref-13"><a class="footnote-ref" href="posts/crawler/#fn-13">11</a></sup>从<code>caller</code>外部来看，我们无法分辨yield出的值是来自<code>caller</code>还是它委派的生成器。而从<code>gen</code>内部来看，我们也不能分辨传给它的值是来自<code>caller</code>还是<code>caller</code>的外面。<code>yield from</code>是一个光滑的管道，值通过它进出<code>gen</code>，一直到<code>gen</code>结束。</p>
<p>协程可以用<code>yield from</code>把工作委派给子协程，还可以接受子协程的返回值。注意到上面的<code>caller</code>打印出"return value of yield-from: done"。当<code>gen</code>完成后，它的返回值成为<code>caller</code>中<code>yield from</code>语句的值。</p>
<pre class="code literal-block"><span></span>    <span class="n">rv</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">gen</span>
</pre>


<p>我们批评过基于回调的异步编程模式，其中最大的不满是关于<code>stack ripping</code>：当一个回调抛出异常，它的堆栈回溯通常是毫无用处的。它只显示出事件循环运行了它，而没有说为什么。那么协程怎么样？</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'my error'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span> <span class="o">=</span> <span class="n">caller_fn</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s2">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">3</span><span class="p">,</span> <span class="ow">in</span> <span class="n">caller_fn</span>
  <span class="n">File</span> <span class="s2">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">gen_fn</span>
<span class="ne">Exception</span><span class="p">:</span> <span class="n">my</span> <span class="n">error</span>
</pre>


<p>这还是比较有用的，当异常抛出时，堆栈回溯显示出<code>caller_fn</code>委派了<code>gen_fn</code>。令人更欣慰的是，你可以像正常函数一样使用异常处理：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">gen_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">yield</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">'uh oh'</span><span class="p">)</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">caller_fn</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">try</span><span class="p">:</span>
<span class="o">...</span>         <span class="k">yield from</span> <span class="n">gen_fn</span><span class="p">()</span>
<span class="o">...</span>     <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
<span class="o">...</span>         <span class="k">print</span><span class="p">(</span><span class="s1">'caught {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span> <span class="o">=</span> <span class="n">caller_fn</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">caller</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">)</span>
<span class="n">caught</span> <span class="n">uh</span> <span class="n">oh</span>
</pre>


<p>所以我们可以像提取子过程一样提取子协程。让我们从fetcher中提取一些有用的子协程。我们先写一个可以读一块数据的协程<code>read</code>：</p>
<pre class="code literal-block"><span></span><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">sock</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_readable</span><span class="p">():</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">))</span>

    <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_READ</span><span class="p">,</span> <span class="n">on_readable</span><span class="p">)</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">f</span>  <span class="c1"># Read one chunk.</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">chunk</span>
</pre>


<p>在<code>read</code>的基础上，<code>read_all</code>协程读取整个信息：</p>
<pre class="code literal-block"><span></span><span class="k">def</span> <span class="nf">read_all</span><span class="p">(</span><span class="n">sock</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Read whole response.</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">response</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>

    <span class="k">return</span> <span class="sa">b</span><span class="s1">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</pre>


<p>如果你换个角度看，它们看起来就像在做阻塞I/O的普通函数一样。但是事实上，<code>read</code>和<code>read_all</code>都是协程。yield from<code>read</code>暂停<code>read_all</code>直到I/O操作完成。当<code>read_all</code>暂停时，事件循环正在做其它的工作等待其他的I/O操作。<code>read</code>在下次循环中完成I/O操作时，<code>read_all</code>恢复运行。</p>
<p>现在，<code>fetch</code>可以直接调用<code>read_all</code>：</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Fetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="c1"># ... connection logic from above, then:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">'ascii'</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">read_all</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
</pre>


<p>神奇的是，Task类不需要做任何改变，它像以前一样驱动<code>fetch</code>协程：</p>
<pre class="code literal-block"><span></span><span class="n">Task</span><span class="p">(</span><span class="n">fetcher</span><span class="o">.</span><span class="n">fetch</span><span class="p">())</span>
<span class="n">loop</span><span class="p">()</span>
</pre>


<p>当<code>read</code>yield一个future时，task从<code>yield from</code>管道中接受它，就像直接从<code>fetch</code>接受一样。当循环解决一个future时，task把它的结果送给<code>fetch</code>,通过管道，<code>read</code>接受到这个值，这完全就像task直接驱动<code>read</code>一样：</p>
<p>图</p>
<p>亲爱的读者，我们已经完成了对asyncio协程探索。我们深入观察了生成器的机制，实现了简单的future和task。我们指出协程是如何利用两个世界的优点：比线程高效，比回调清晰。当然真正的asyncio比我们这个简化版本要复杂的多。真正的框架需要处理zero-copyI/0，公平调度，异常处理和其他大量特性。</p>
<p>使用asyncio编写协程代码比你现在看到的要简单的多。在前面的代码中，我们从基本原理去实现协程，所以你看到了回调，task和future，甚至非阻塞套接字和<code>select</code>调用。但是当用asyncio编写应用，这些都不会出现在你的代码中。我们承诺过，你可以像这样下载一个网页：</p>
<pre class="code literal-block"><span></span>    <span class="nd">@asyncio.coroutine</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="n">response</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">body</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre>


<p>对我们的探索还满意么？回到我们原始的任务：使用asyncio写一个网络爬虫。</p>
<h3>Coordinating Coroutines</h3>
<p>我们从描述爬虫如何工作开始。现在是时候用asynio去实现它了。</p>
<p>我们爬虫从获取第一个网页开始，解析出链接并把它们加到队列中。此后它开始傲游整个网站，并发的获取网页。倒是由于客户端和服务端的限制，我们希望有一个最大数目的worker。任何时候一个worker完成一个网页的获取，它应该立即从队列中取出下一个链接。我们会遇到没有事干的时候，所以worker必须能够暂停。一旦又有worker获取一个有很多链接的网页，队列会突增，暂停的worker立马被唤醒。最后，当任务完成后我们的程序必须能退出。</p>
<p>假如你的worker是线程，怎样去描述你的算法？我们可以使用Python标准库中的同步队列。每次有新的一项加入，队列增加它的tasks计数器。线程worker完成一个任务后调用<code>task_done</code>。主线程阻塞在<code>Queue.join</code>，直到tasks计数器与<code>task_done</code>调用次数相匹配，然后退出。</p>
<p>通过个一asynio队列，协程使用和线程一样的模式来实现。首先我们导入它<sup id="fnref-6"><a class="footnote-ref" href="posts/crawler/#fn-6">3</a></sup>：</p>
<pre class="code literal-block"><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">asyncio</span> <span class="kn">import</span> <span class="n">JoinableQueue</span> <span class="k">as</span> <span class="n">Queue</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># In Python 3.5, asyncio.JoinableQueue is</span>
    <span class="c1"># merged into Queue.</span>
    <span class="kn">from</span> <span class="nn">asyncio</span> <span class="kn">import</span> <span class="n">Queue</span>
</pre>


<p>我们把worker的共享状态收集在一个crawler类中,主要的逻辑写在<code>crawl</code>方法中。我们在一个协程中启动<code>crawl</code>,运行asyncio的事件循环直到<code>crawl</code>完成：</p>
<pre class="code literal-block"><span></span><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

<span class="n">crawler</span> <span class="o">=</span> <span class="n">crawling</span><span class="o">.</span><span class="n">Crawler</span><span class="p">(</span><span class="s1">'http://xkcd.com'</span><span class="p">,</span>
                           <span class="n">max_redirect</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">crawler</span><span class="o">.</span><span class="n">crawl</span><span class="p">())</span>
</pre>


<p>crawler用一个跟URL和最大重定向数来初始化，它把<code>(URL, max_redirect</code>)序对放入队列中。(为什么要这样做，敬请期待)</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Crawler</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_url</span><span class="p">,</span> <span class="n">max_redirect</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_tasks</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_redirect</span> <span class="o">=</span> <span class="n">max_redirect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seen_urls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># aiohttp's ClientSession does connection pooling and</span>
        <span class="c1"># HTTP keep-alives for us.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">(</span><span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span>

        <span class="c1"># Put (URL, max_redirect) in the queue.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">root_url</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_redirect</span><span class="p">))</span>
</pre>


<p>现在队列中未完成的任务数是1。回到我们的主程序，启动事件循环和<code>crawl</code>方法：</p>
<pre class="code literal-block"><span></span><span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">crawler</span><span class="o">.</span><span class="n">crawl</span><span class="p">())</span>
</pre>


<p><code>crawl</code>协程唤起workers。它像一个主线程：阻塞在<code>join</code>上直到所有任务完成，同时workers在后台运行。</p>
<pre class="code literal-block"><span></span>    <span class="nd">@asyncio.coroutine</span>
    <span class="k">def</span> <span class="nf">crawl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Run the crawler until all work is done."""</span>
        <span class="n">workers</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="p">())</span>
                   <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_tasks</span><span class="p">)]</span>

        <span class="c1"># When all work is done, exit.</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">:</span>
            <span class="n">w</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</pre>


<p>如果worker是线程，可能我们不会一次把它们全部创建出来。为了避免创建线程的昂贵代价，通常一个线程池会按需增长。但是协程很便宜，我们简单的把他们全部创建出来。</p>
<p>怎么关闭这个<code>crawler</code>很有趣。当<code>join</code>完成，worker存活但是被暂停：他们等待更多的URL。所以主协程在退出之前清除它们。否则Python解释器关闭调用所有对象的析构函数，活着的worker叫喊到：</p>
<pre class="code literal-block"><span></span><span class="n">ERROR</span><span class="o">:</span><span class="n">asyncio</span><span class="o">:</span><span class="n">Task</span> <span class="n">was</span> <span class="n">destroyed</span> <span class="n">but</span> <span class="n">it</span> <span class="k">is</span> <span class="n">pending</span><span class="o">!</span>
</pre>


<p><code>cancel</code>又是如何工作的呢？生成器还有一个我们还没介绍的特点。你可以从外部抛一个异常给它：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span> <span class="o">=</span> <span class="n">gen_fn</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>  <span class="c1"># Start the generator as usual.</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">gen</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">Exception</span><span class="p">(</span><span class="s1">'error'</span><span class="p">))</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">3</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
  <span class="n">File</span> <span class="s2">"&lt;input&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">2</span><span class="p">,</span> <span class="ow">in</span> <span class="n">gen_fn</span>
<span class="ne">Exception</span><span class="p">:</span> <span class="n">error</span>
</pre>


<p>生成器被<code>throw</code>恢复，但是他现在抛出一个异常。如何生成器没有捕获异常的代码，这个异常被传递到顶层。所以注销一个协程：</p>
<pre class="code literal-block"><span></span>    <span class="c1"># Method of Task class.</span>
    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="n">CancelledError</span><span class="p">)</span>
</pre>


<p>任何时候生成器在<code>yield from</code>语句暂停，被恢复并且抛出一个异常。我们在task的<code>step</code>方法中处理撤销。</p>
<p>现在worker直到他被注销了，所以当它被销毁时,它不再抱怨。</p>
<p>一旦<code>crawl</code>注销了worker，它就退出。同时事件循环看见这个协程结束了，也就退出l。</p>
<pre class="code literal-block"><span></span><span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">crawler</span><span class="o">.</span><span class="n">crawl</span><span class="p">())</span>
</pre>


<p><code>crawl</code>方法包含了所有主协程需要做的事。而worker则完成了从队列中获取URL，获取网页，解析它们得到新的链接。每个worker独立的运行<code>worker</code>协程：</p>
<pre class="code literal-block"><span></span>    <span class="nd">@asyncio.coroutine</span>
    <span class="k">def</span> <span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">url</span><span class="p">,</span> <span class="n">max_redirect</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="c1"># Download page and add new links to self.q.</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">max_redirect</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
</pre>


<p>Python看见这段代码包含<code>yield from</code>语句，就把它编译成生成器函数。所以在<code>crawl</code>方法中，我们调用了10次<code>self.work</code>,但并没有真正执行，它仅仅创建了10个生成器对象并把它们包装成Task对象。task接收生成器yield的future，通过调用send方法，future的结果做为send的参数，来驱动它。由于生成器有自己的栈帧，它们可以独立运行，独立的局部变量和指令指针。</p>
<p>worker使用队列来协调， 等待新的URL：</p>
<pre class="code literal-block"><span></span>    <span class="n">url</span><span class="p">,</span> <span class="n">max_redirect</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre>


<p>队列的<code>get</code>方法也是一个协程，它一直暂停到有新的URL进入队列。</p>
<p>碰巧，这也是最后crawl停止时，协程暂停的地方。当主协程注销worker时，从协程的角度，<code>yield from</code>抛出<code>CancelledError</code>结束了它在循环中的最后旅程。</p>
<p>worker获取一个网页，解析链接，把新的链接放入队列中，接着调用<code>task_done</code>减小计数器。最终一个worker遇到一个没有新链接的网页，并且队列里也没有任务，这次<code>task_done</code>的调用使计数器减为0，而<code>crawl</code>正阻塞在<code>join</code>方法上，现在它就可以结束了。</p>
<p>我们承诺过要解释为什么队列中要使用序对，像这样：</p>
<pre class="code literal-block"><span></span><span class="c1"># URL to fetch, and the number of redirects left.</span>
<span class="p">(</span><span class="s1">'http://xkcd.com/353'</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre>


<p>新的URL的重定向次数是10。获取一个特别的URL会重定向一个新的位置。我们减小重定向次数，并把新的URL放入队列中。</p>
<pre class="code literal-block"><span></span><span class="c1"># URL with a trailing slash. Nine redirects left.</span>
<span class="p">(</span><span class="s1">'http://xkcd.com/353/'</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
</pre>


<p>我们使用的<code>aiohttp</code>默认的会重定向返回最终的结果。但是，我们告诉它不要这样做，爬虫自己处理重定向。所以它可以合并那些目的相同的重定向路径：如果我们已经看到一个URL，说明它已经从其他的地方走过这条路了。</p>
<pre class="code literal-block"><span></span>    <span class="nd">@asyncio.coroutine</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">max_redirect</span><span class="p">):</span>
        <span class="c1"># Handle redirects ourselves.</span>
        <span class="n">response</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="n">url</span><span class="p">,</span> <span class="n">allow_redirects</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_redirect</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">max_redirect</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">next_url</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s1">'location'</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">next_url</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen_urls</span><span class="p">:</span>
                        <span class="c1"># We have been down this path before.</span>
                        <span class="k">return</span>

                    <span class="c1"># Remember we have seen this URL.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">seen_urls</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">next_url</span><span class="p">)</span>

                    <span class="c1"># Follow the redirect. One less redirect remains.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="n">next_url</span><span class="p">,</span> <span class="n">max_redirect</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
             <span class="k">else</span><span class="p">:</span>
                 <span class="n">links</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_links</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
                 <span class="c1"># Python set-logic:</span>
                 <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seen_urls</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">((</span><span class="n">link</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_redirect</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seen_urls</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Return connection to pool.</span>
            <span class="k">yield from</span> <span class="n">response</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre>


<p>如果这是多进程代码，就有可能遇到讨厌的竞争条件。比如，一个work检查一个链接是否在<code>seen_urls</code>中，如果没有它就把这个链接加到队列中并把它放到<code>seen_urls</code>中。如果它在这两步操作之间被中断，而另一个work解析到相同的链接，发现它并没有出现在<code>seen_urls</code>中就把它加入队列中。这导致同样的链接在队列中出现两次，做了重复的工作和错误的统计。</p>
<p>然而，一个协程只在<code>yield from</code>是才会被中断。这是协程比多线程少遇到竞争条件的关键。多线程必须获得锁来明确的进入一个临界区，否则它就是可中断的。而Python的协程默认是不会被中断的，只有它yield主动放弃控制权。</p>
<p>我们不再需要在用回调方式时的fetcher类了。这个类只是不高效回调的一个变通方法：在等待I/O时，它需要一个存储状态的地方，因为局部变量并不能在函数调用间保留。倒是<code>fetch</code>协程可以像普通函数一样用局部变量保存它的状态，所以我们不再需要一个类。</p>
<p>当<code>fetch</code>完成对服务器回应的处理，它返回到调用它的work。work调用<code>task_done</code>,接着从队列中取出一个URL。</p>
<p>当<code>fetch</code>把新的链接放入队列中，它增加未完成的任务计数器。主协程在等待<code>q.join</code>。而当没有新的链接并且这是队列中最后一个URL，work调用<code>task_done</code>，任务计数器变为0，主协程从<code>join</code>中退出。</p>
<p>与work和主协程一起工作的队列代码像这样：</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_join_future</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unfinished_tasks</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># ... other initialization ...</span>

    <span class="k">def</span> <span class="nf">put_nowait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unfinished_tasks</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># ... store the item ...</span>

    <span class="k">def</span> <span class="nf">task_done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unfinished_tasks</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unfinished_tasks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_join_future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

    <span class="nd">@asyncio.coroutine</span>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unfinished_tasks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_future</span>
</pre>


<p>主协程<code>crawl</code>yield from<code>join</code>。所以当最后一个workd把计数器减为0，它告诉<code>crawl</code>恢复运行。</p>
<p>旅程快要结束了。我们的程序从<code>crawl</code>调用开始：</p>
<pre class="code literal-block"><span></span><span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crawler</span><span class="o">.</span><span class="n">crawl</span><span class="p">())</span>
</pre>


<p>程序如何结束？因为<code>crawl</code>是一个生成器函数。调用它返回一个生成器。为了驱动它，asyncio把它包装成一个task：</p>
<p>class EventLoop:
    def run_until_complete(self, coro):
        """Run until the coroutine is done."""
        task = Task(coro)
        task.add_done_callback(stop_callback)
        try:
            self.run_forever()
        except StopError:
            pass</p>
<p>class StopError(BaseException):
    """Raised to stop the event loop."""</p>
<p>def stop_callback(future):
    raise StopError</p>
<pre class="code literal-block"><span></span><span class="err">当这个任务完成，它抛出</span><span class="sb">`StopError`</span><span class="p">,</span> <span class="err">事件循环把这个异常当作正常退出的信号。</span>

<span class="err">但是，</span><span class="nx">task的</span><span class="sb">`add_done_callbock`</span><span class="err">和</span><span class="sb">`result`</span><span class="err">方法又是什么呢？你可能认为</span><span class="nx">task就像一个future</span><span class="err">，不错，你的直觉是对的。我们必须承认一个向你隐藏的细节，</span><span class="nx">task是future</span><span class="err">。</span>

<span class="sb">```python</span>
<span class="sb">class Task(Future):</span>
<span class="sb">    """A coroutine wrapped in a Future."""</span>
</pre>


<p>通常，一个future被别人调用<code>set_result</code>。但是task，当协程结束时，它自己解决自己。记得我们解释过当Python生成器返回时，它抛出一个特殊的<code>StopIteration</code>异常：</p>
<pre class="code literal-block"><span></span>    <span class="c1"># Method of class Task.</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CancelledError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cancelled</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span>
        <span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>

            <span class="c1"># Task resolves itself with coro's return</span>
            <span class="c1"># value.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">next_future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
</pre>


<p>所以当事件循环调用<code>task.add_done_callback(stop_callback)</code>，它就准备被这个task结束。在看一次<code>run_until_complete</code>；</p>
<pre class="code literal-block"><span></span>    <span class="c1"># Method of event loop.</span>
    <span class="k">def</span> <span class="nf">run_until_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">stop_callback</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">StopError</span><span class="p">:</span>
            <span class="k">pass</span>
</pre>


<p>当task捕获<code>StopIteration</code>并解决自己，这个回调重循环中抛出<code>StopError</code>。循环结束调用栈回到<code>run_until_complete</code>。我们的程序结束。</p>
<h3>Conclusion</h3>
<p>现代的程序越来越多是I/O密集型而不是CPU密集型。对于这样的程序，Python的线程和不合适：全局锁阻止真正的并行计算，并且抢占切换也导致他们更容易出现竞争。异步通常是正确的选择。但是随着基于回调的异步代码增加，它会变得非常混乱。协程是一个更整洁的替代者。它们自然的重构成子过程，有健全的异常处理和栈追溯。</p>
<p>如果我们换个角度看<code>yield from</code>语句，一个协程看起来像一个传统的线程。甚至我们采用金典的多线程模式编程，不需要重新发明。因此，与回调相比，协程更适合有经验的多线程的编码者。</p>
<p>但是当我们打开眼睛关注<code>yield from</code>语句，我们能看到协程放弃控制权的标志点。不像多线程，协程展示出我们的代码哪里可以被中断哪里不能。在Glyph Lefkowitz富有启发性的文章"Unyielding"<sup id="fnref-4"><a class="footnote-ref" href="posts/crawler/#fn-4">1</a></sup>："线程让局部推理变得困难，然而局部推理可能是软件开发中最重要的事"。然而，明确的yield，让"通过子过程本身而不是整个系统理解它的行为(应此，正确性)"成为可能。</p>
<p>这章写于Python和异步的复兴时期。你刚学到的基于生成器的的协程，在2014年发布在Python 3.4的"asyncio"模块。2015年9月，Python 3.5发布，协程成为语言的一部分。这个原生的协程通过"async def"来声明, 使用"await"而不是"yield from"委托一个协程或者等待Future。</p>
<p>除了这些优点，核心的思想不变。Python新的原生协程与生成器只是在语法上不同，工作原理非常相似。事实上，在Python解释器中它们公用同一个实现方法。Task，Future和事件循环扮演这在asynico中同样的角色。</p>
<p>你已经知道asyncio协程是如何工作的了，现在你可以忘记大部分的细节。这些机制隐藏在一个整洁的接口下。但是你对这基本原理的理解能让你在现代异步环境下正确而高效的编写代码。</p>
<p><latex></latex></p>
<p><markdown></markdown></p>
<div class="footnote">
<hr>
<ol>
<li id="fn-4">
<p><a href="https://glyph.twistedmatrix.com/2014/02/unyielding.html">https://glyph.twistedmatrix.com/2014/02/unyielding.html</a> <a class="footnote-backref" href="posts/crawler/#fnref-4" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn-5">
<p><a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a> <a class="footnote-backref" href="posts/crawler/#fnref-5" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn-6">
<p><a href="https://docs.python.org/3/library/asyncio-sync.html">https://docs.python.org/3/library/asyncio-sync.html</a> <a class="footnote-backref" href="posts/crawler/#fnref-6" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
<li id="fn-7">
<p>For a complex solution to this problem, see <a href="http://www.tornadoweb.org/en/stable/stack_context.html">http://www.tornadoweb.org/en/stable/stack_context.html</a> <a class="footnote-backref" href="posts/crawler/#fnref-7" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
<li id="fn-8">
<p><a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a> <a class="footnote-backref" href="posts/crawler/#fnref-8" title="Jump back to footnote 5 in the text">↩</a></p>
</li>
<li id="fn-9">
<p>The actual <code>asyncio.Queue</code> implementation uses an <code>asyncio.Event</code> in place of the Future shown here. The difference is an Event can be reset, whereas a Future cannot transition from resolved back to pending. <a class="footnote-backref" href="posts/crawler/#fnref-9" title="Jump back to footnote 6 in the text">↩</a></p>
</li>
<li id="fn-10">
<p>The <code>@asyncio.coroutine</code> decorator is not magical. In fact, if it decorates a generator function and the <code>PYTHONASYNCIODEBUG</code> environment variable is not set, the decorator does practically nothing. It just sets an attribute, <code>_is_coroutine</code>, for the convenience of other parts of the framework. It is possible to use asyncio with bare generators not decorated with <code>@asyncio.coroutine</code> at all. <a class="footnote-backref" href="posts/crawler/#fnref-10" title="Jump back to footnote 7 in the text">↩</a></p>
</li>
<li id="fn-11">
<p>Jesse listed indications and contraindications for using async in <a href="http://pyvideo.org/video/2565/what-is-async-how-does-it-work-and-when-should">"What Is Async, How Does It Work, And When Should I Use It?":</a>. Mike Bayer compared the throughput of asyncio and multithreading for different workloads in <a href="http://techspot.zzzeek.org/2015/02/15/asynchronous-python-and-databases/">"Asynchronous Python and Databases":</a>
 <a class="footnote-backref" href="posts/crawler/#fnref-11" title="Jump back to footnote 8 in the text">↩</a></p>
</li>
<li id="fn-bayer">
<p>Mike Bayer compared the throughput of asyncio and multithreading for different workloads in his "Asynchronous Python and Databases": http://techspot.zzzeek.org/2015/02/15/asynchronous-python-and-databases/

<markdown> <a class="footnote-backref" href="posts/crawler/#fnref-bayer" title="Jump back to footnote 9 in the text">↩</a></markdown></p>
</li>
<li id="fn-12">
<p>This future has many deficiencies. For example, once this future is resolved, a coroutine that yields it should resume immediately instead of pausing, but with our code it does not. See asyncio's Future class for a complete implementation. <a class="footnote-backref" href="posts/crawler/#fnref-12" title="Jump back to footnote 10 in the text">↩</a></p>
</li>
<li id="fn-13">
<p>In fact, this is exactly how "yield from" works in CPython. A function increments its instruction pointer before executing each statement. But after the outer generator executes "yield from", it subtracts 1 from its instruction pointer to keep itself pinned at the "yield from" statement. Then it yields to <em>its</em> caller. The cycle repeats until the inner generator throws <code>StopIteration</code>, at which point the outer generator finally allows itself to advance to the next instruction. <a class="footnote-backref" href="posts/crawler/#fnref-13" title="Jump back to footnote 11 in the text">↩</a></p>
</li>
<li id="fn-14">
<p>Python's global interpreter lock prohibits running Python code in parallel in one process anyway. Parallelizing CPU-bound algorithms in Python requires multiple processes, or writing the parallel portions of the code in C. But that is a topic for another day. <a class="footnote-backref" href="posts/crawler/#fnref-14" title="Jump back to footnote 12 in the text">↩</a></p>
</li>
<li id="fn-15">
<p>Even calls to <code>send</code> can block, if the recipient is slow to acknowledge outstanding messages and the system's buffer of outgoing data is full. <a class="footnote-backref" href="posts/crawler/#fnref-15" title="Jump back to footnote 13 in the text">↩</a></p>
</li>
<li id="fn-16">
<p>Guido introduced the standard asyncio library, called "Tulip" then, at PyCon 2013.
 <a class="footnote-backref" href="posts/crawler/#fnref-16" title="Jump back to footnote 14 in the text">↩</a></p>
</li>
<li id="fn-17">
<p>Python 3.5's built-in coroutines are described in <a href="https://www.python.org/dev/peps/pep-0492/">PEP 492</a>, "Coroutines with async and await syntax." <a class="footnote-backref" href="posts/crawler/#fnref-17" title="Jump back to footnote 15 in the text">↩</a></p>
</li>
</ol>
</div>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/flask-dev/" class="u-url">成为Flask贡献者</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Tao Qingyun
            </span></p>
            <p class="dateline"><a href="posts/flask-dev/" rel="bookmark"><time class="published dt-published" datetime="2016-05-21T21:48:31+08:00" title="2016-05-21 21:48">2016-05-21 21:48</time></a></p>
                <p class="commentline">
        
    <a href="posts/flask-dev/#disqus_thread" data-disqus-identifier="cache/posts/flask-dev.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>当你clone下Flask项目之后：</p>
<ol>
<li>
<p>使用virtualenv或者venv创建虚拟环境</p>
</li>
<li>
<p><code>pip install -e .</code>用开发者模式安装本地Flask</p>
</li>
<li>
<p><code>py.test tests</code>运行测试代码 (如果不用上面的方法，py.test很难用起来)</p>
</li>
<li>
<p>在github fork后<code>git add remote fork https://github.com/&lt;username&gt;/flask.git</code></p>
</li>
</ol>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/python-interpreter/" class="u-url">A Python Interpreter Written in Python</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Tao Qingyun
            </span></p>
            <p class="dateline"><a href="posts/python-interpreter/" rel="bookmark"><time class="published dt-published" datetime="2016-05-09T11:32:25+08:00" title="2016-05-09 11:32">2016-05-09 11:32</time></a></p>
                <p class="commentline">
        
    <a href="posts/python-interpreter/#disqus_thread" data-disqus-identifier="cache/posts/python-interpreter.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p><em>Allison是Dropbox的工程师，在那里她维护着世界上最大的由Python客户组成的网络。在Dropbox之前，她是Recurse Center的导师, 曾在纽约写作。在北美的PyCon做过关于Python内部机制的演讲，并且她喜欢奇怪的bugs。她的博客地址是<a href="http://akaptur.com">akaptur.com</a>.</em></p>
<h3>Introduction</h3>
<p>Byterun是一个用Python实现的Python解释器。随着我在Byterun上的工作，我惊讶并很高兴地的发现，这个Python解释器的基础结构可以满足500行的限制。在这一章我们会搞清楚这个解释器的结构，给你足够的知识探索下去。我们的目标不是向你展示解释器的每个细节---像编程和计算机科学其他有趣的领域一样，你可能会投入几年的时间去搞清楚这个主题。</p>
<p>Byterun是Ned Batchelder和我完成的，建立在Paul Swartz的工作之上。它的结构和主要的Python实现（CPython）差不多，所以理解Byterun会帮助你理解大多数解释器特别是CPython解释器。（如果你不知道你用的是什么Python，那么很可能它就是CPython）。尽管Byterun很小，但它能执行大多数简单的Python程序。</p>
<h4>A Python Interpreter</h4>
<p>在开始之前，让我们缩小一下“Pyhton解释器”的意思。在讨论Python的时候，“解释器”这个词可以用在很多不同的地方。有的时候解释器指的是REPL，当你在命令行下敲下<code>python</code>时所得到的交互式环境。有时候人们会相互替代的使用Python解释器和Python来说明执行Python代码的这一过程。在本章，“解释器”有一个更精确的意思：执行Python程序过程中的最后一步。</p>
<p>在解释器接手之前，Python会执行其他3个步骤：词法分析，语法解析和编译。这三步合起来把源代码转换成_code object_,它包含着解释器可以理解的指令。而解释器的工作就是解释code object中的指令。</p>
<p>你可能很奇怪执行Python代码会有编译这一步。Python通常被称为解释型语言，就像Ruby，Perl一样，它们和编译型语言相对，比如C，Rust。然而，这里的术语并不是它看起来的那样精确。大多数解释型语言包括Python，确实会有编译这一步。而Python被称为解释型的原因是相对于编译型语言，它在编译这一步的工作相对较少（解释器做相对多的工作）。在这章后面你会看到，Python的编译器比C语言编译器需要更少的关于程序行为的信息。</p>
<h4>A Python Python Interpreter</h4>
<p>Byterun是一个用Python写的Python解释器，这点可能让你感到奇怪，但没有比用C语言写C语言编译器更奇怪。（事实上，广泛使用的gcc编译器就是用C语言本身写的）你可以用几乎的任何语言写一个Python解释器。</p>
<p>用Python写Python既有优点又有缺点。最大的缺点就是速度：用Byterun执行代码要比用CPython执行慢的多，CPython解释器是用C语言实现的并做了优化。然而Byterun是为了学习而设计的，所以速度对我们不重要。使用Python最大优点是我们可以<em>仅仅</em>实现解释器，而不用担心Python运行时的部分，特别是对象系统。比如当Byterun需要创建一个类时，它就会回退到“真正”的Python。另外一个优势是Byterun很容易理解，部分原因是它是用高级语言写的（Python！）（另外我们不会对解释器做优化 --- 再一次，清晰和简单比速度更重要）</p>
<h3>Building an Interpreter</h3>
<p>在我们考察Byterun代码之前，我们需要一些对解释器结构的高层次视角。Python解释器是如何工作的？</p>
<p>Python解释器是一个_虚拟机_,模拟真实计算机的软件。我们这个虚拟机是栈机器，它用几个栈来完成操作（与之相对的是寄存器机器，它从特定的内存地址读写数据）。</p>
<p>Python解释器是一个_字节码解释器_：它的输入是一些命令集合称作_字节码_。当你写Python代码时，词法分析器，语法解析器和编译器生成code object让解释器去操作。每个code object都包含一个要被执行的指令集合 --- 它就是字节码 --- 另外还有一些解释器需要的信息。字节码是Python代码的一个_中间层表示_：它以一种解释器可以理解的方式来表示源代码。这和汇编语言作为C语言和机器语言的中间表示很类似。</p>
<h4>A Tiny Interpreter</h4>
<p>为了让说明更具体，让我们从一个非常小的解释器开始。它只能计算两个数的和，只能理解三个指令。它执行的所有代码只是这三个指令的不同组合。下面就是这三个指令：</p>
<ul>
<li><code>LOAD_VALUE</code></li>
<li><code>ADD_TWO_VALUES</code></li>
<li><code>PRINT_ANSWER</code></li>
</ul>
<p>我们不关心词法，语法和编译，所以我们也不在乎这些指令是如何产生的。你可以想象，你写下<code>7 + 5</code>，然后一个编译器为你生成那三个指令的组合。如果你有一个合适的编译器，你甚至可以用Lisp的语法来写，只要它能生成相同的指令。</p>
<p>假设</p>
<pre class="code literal-block"><span></span><span class="mi">7</span> <span class="o">+</span> <span class="mi">5</span>
</pre>


<p>生成这样的指令集：</p>
<pre class="code literal-block"><span></span><span class="n">what_to_execute</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"instructions"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"LOAD_VALUE"</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># the first number</span>
                     <span class="p">(</span><span class="s2">"LOAD_VALUE"</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>  <span class="c1"># the second number</span>
                     <span class="p">(</span><span class="s2">"ADD_TWO_VALUES"</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s2">"PRINT_ANSWER"</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
    <span class="s2">"numbers"</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="p">}</span>
</pre>


<p>Python解释器是一个_栈机器_，所以它必须通过操作栈来完成这个加法。(\aosafigref{500l.interpreter.stackmachine}.)解释器先执行第一条指令，<code>LOAD_VALUE</code>，把第一个数压到栈中。接着它把第二个数也压到栈中。然后，第三条指令，<code>ADD_TWO_VALUES</code>,先把两个数从栈中弹出，加起来，再把结果压入栈中。最后一步，把结果弹出并输出。</p>
<p>\aosafigure[240pt]{interpreter-images/interpreter-stack.png}{A stack machine}{500l.interpreter.stackmachine}</p>
<p><code>LOAD_VALUE</code>这条指令告诉解释器把一个数压入栈中，但指令本身并没有指明这个数是多少。指令需要一个额外的信息告诉解释器去哪里找到这个数。所以我们的指令集有两个部分：指令本身和一个常量列表。（在Python中，字节码就是我们称为的“指令”，而解释器执行的是_code object_。）</p>
<p>为什么不把数字直接嵌入指令之中？想象一下，如果我们加的不是数字，而是字符串。我们可不想把字符串这样的东西加到指令中，因为它可以有任意的长度。另外，我们这种设计也意味着我们只需要对象的一份拷贝，比如这个加法 <code>7 + 7</code>, 现在常量表 <code>"numbers"</code>只需包含一个<code>7</code>。</p>
<p>你可能会想为什么会需要除了<code>ADD_TWO_VALUES</code>之外的指令。的确，对于我们两个数加法，这个例子是有点人为制作的意思。然而，这个指令却是建造更复杂程序的轮子。比如，就我们目前定义的三个指令，只要给出正确的指令组合，我们可以做三个数的加法，或者任意个数的加法。同时，栈提供了一个清晰的方法去跟踪解释器的状态，这为我们增长的复杂性提供了支持。</p>
<p>现在让我们来完成我们的解释器。解释器对象需要一个栈，它可以用一个列表来表示。它还需要一个方法来描述怎样执行每条指令。比如，<code>LOAD_VALUE</code>会把一个值压入栈中。</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Interpreter</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">LOAD_VALUE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PRINT_ANSWER</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ADD_TWO_VALUES</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">first_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">second_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">first_num</span> <span class="o">+</span> <span class="n">second_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
</pre>


<p>这三个方法完成了解释器所理解的三条指令。但解释器还需要一样东西：一个能把所有东西结合在一起并执行的方法。这个方法就叫做<code>run_code</code>, 它把我们前面定义的字典结构<code>what-to-execute</code>作为参数，循环执行里面的每条指令，如何指令有参数，处理参数，然后调用解释器对象中相应的方法。</p>
<pre class="code literal-block"><span></span>    <span class="k">def</span> <span class="nf">run_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what_to_execute</span><span class="p">):</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="n">what_to_execute</span><span class="p">[</span><span class="s2">"instructions"</span><span class="p">]</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="n">what_to_execute</span><span class="p">[</span><span class="s2">"numbers"</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">each_step</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
            <span class="n">instruction</span><span class="p">,</span> <span class="n">argument</span> <span class="o">=</span> <span class="n">each_step</span>
            <span class="k">if</span> <span class="n">instruction</span> <span class="o">==</span> <span class="s2">"LOAD_VALUE"</span><span class="p">:</span>
                <span class="n">number</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">[</span><span class="n">argument</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">LOAD_VALUE</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">instruction</span> <span class="o">==</span> <span class="s2">"ADD_TWO_VALUES"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ADD_TWO_VALUES</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">instruction</span> <span class="o">==</span> <span class="s2">"PRINT_ANSWER"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">PRINT_ANSWER</span><span class="p">()</span>
</pre>


<p>为了测试，我们创建一个解释器对象，然后用前面定义的 7 + 5 的指令集来调用<code>run_code</code>。</p>
<pre class="code literal-block"><span></span>    <span class="n">interpreter</span> <span class="o">=</span> <span class="n">Interpreter</span><span class="p">()</span>
    <span class="n">interpreter</span><span class="o">.</span><span class="n">run_code</span><span class="p">(</span><span class="n">what_to_execute</span><span class="p">)</span>
</pre>


<p>显然，它会输出12</p>
<p>尽管我们的解释器功能受限，但这个加法过程几乎和真正的Python解释器是一样的。这里，我们还有几点要注意。</p>
<p>首先，一些指令需要参数。在真正的Python bytecode中，大概有一半的指令有参数。像我们的例子一样，参数和指令打包在一起。注意_指令_的参数和传递给对应方法的参数是不同的。</p>
<p>第二，指令<code>ADD_TWO_VALUES</code>不需要任何参数，它从解释器栈中弹出所需的值。这正是以栈为基础的解释器的特点。</p>
<p>记得我们说过只要给出合适的指令集，不需要对解释器做任何改变，我们就能做多个数的加法。考虑下面的指令集，你觉得会发生什么？如果你有一个合适的编译器，什么代码才能编译出下面的指令集？</p>
<pre class="code literal-block"><span></span>    <span class="n">what_to_execute</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">"instructions"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"LOAD_VALUE"</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"LOAD_VALUE"</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"ADD_TWO_VALUES"</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"LOAD_VALUE"</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"ADD_TWO_VALUES"</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"PRINT_ANSWER"</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
        <span class="s2">"numbers"</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span> <span class="p">}</span>
</pre>


<p>从这点出发，我们开始看到这种结构的可扩展性：我们可以通过向解释器对象增加方法来描述更多的操作（只要有一个编译器能为我们生成组织良好的指令集）。</p>
<h4>Variables</h4>
<p>接下来给我们的解释器增加变量的支持。我们需要一个保存变量值的指令，<code>STORE_NAME</code>;一个取变量值的指令<code>LOAD_NAME</code>;和一个变量到值的映射关系。目前，我们会忽略命名空间和作用域，所以我们可以把变量和值的映射直接存储在解释器对象中。最后，我们要保证<code>what_to_execute</code>除了一个常量列表，还要有个变量名字的列表。</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">s</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
<span class="c1"># a friendly compiler transforms `s` into:</span>
    <span class="n">what_to_execute</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">"instructions"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"LOAD_VALUE"</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"STORE_NAME"</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"LOAD_VALUE"</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"STORE_NAME"</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"LOAD_NAME"</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"LOAD_NAME"</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"ADD_TWO_VALUES"</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                         <span class="p">(</span><span class="s2">"PRINT_ANSWER"</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
        <span class="s2">"numbers"</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="s2">"names"</span><span class="p">:</span>   <span class="p">[</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">]</span> <span class="p">}</span>
</pre>


<p>我们的新的的实现在下面。为了跟踪哪名字绑定到那个值，我们在<code>__init__</code>方法中增加一个<code>environment</code>字典。我们也增加了<code>STORE_NAME</code>和<code>LOAD_NAME</code>方法，它们获得变量名，然后从<code>environment</code>字典中设置或取出这个变量值。</p>
<p>现在指令参数就有两个不同的意思，它可能是<code>numbers</code>列表的索引，也可能是<code>names</code>列表的索引。解释器通过检查所执行的指令就能知道是那种参数。而我们打破这种逻辑 ，把指令和它所用何种参数的映射关系放在另一个单独的方法中。</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Interpreter</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">environment</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">STORE_NAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">environment</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">LOAD_NAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">environment</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_argument</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instruction</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">what_to_execute</span><span class="p">):</span>
        <span class="sd">""" Understand what the argument to each instruction means."""</span>
        <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"LOAD_VALUE"</span><span class="p">]</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"LOAD_NAME"</span><span class="p">,</span> <span class="s2">"STORE_NAME"</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">:</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="n">what_to_execute</span><span class="p">[</span><span class="s2">"numbers"</span><span class="p">][</span><span class="n">argument</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="n">what_to_execute</span><span class="p">[</span><span class="s2">"names"</span><span class="p">][</span><span class="n">argument</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">argument</span>

    <span class="k">def</span> <span class="nf">run_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what_to_execute</span><span class="p">):</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="n">what_to_execute</span><span class="p">[</span><span class="s2">"instructions"</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">each_step</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
            <span class="n">instruction</span><span class="p">,</span> <span class="n">argument</span> <span class="o">=</span> <span class="n">each_step</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_argument</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">what_to_execute</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">instruction</span> <span class="o">==</span> <span class="s2">"LOAD_VALUE"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">LOAD_VALUE</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">instruction</span> <span class="o">==</span> <span class="s2">"ADD_TWO_VALUES"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ADD_TWO_VALUES</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">instruction</span> <span class="o">==</span> <span class="s2">"PRINT_ANSWER"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">PRINT_ANSWER</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">instruction</span> <span class="o">==</span> <span class="s2">"STORE_NAME"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">STORE_NAME</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">instruction</span> <span class="o">==</span> <span class="s2">"LOAD_NAME"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">LOAD_NAME</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
</pre>


<p>仅仅五个指令，<code>run_code</code>这个方法已经开始变得冗长了。如果保持这种结构，那么每条指令都需要一个<code>if</code>分支。这里，我们要利用Python的动态方法查找。我们总会给一个称为<code>FOO</code>的指令定义一个名为<code>FOO</code>的方法，这样我们就可用Python的<code>getattr</code>函数在运行时动态查找方法，而不用这个大大的分支结构。<code>run_code</code>方法现在是这样：</p>
<pre class="code literal-block"><span></span>    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what_to_execute</span><span class="p">):</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="n">what_to_execute</span><span class="p">[</span><span class="s2">"instructions"</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">each_step</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
            <span class="n">instruction</span><span class="p">,</span> <span class="n">argument</span> <span class="o">=</span> <span class="n">each_step</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_argument</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="n">what_to_execute</span><span class="p">)</span>
            <span class="n">bytecode_method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instruction</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">argument</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">bytecode_method</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bytecode_method</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span>
</pre>


<h3>Real Python Bytecode</h3>
<p>现在，放弃我们的小指令集，去看看真正的Python字节码。字节码的结构和我们的小解释器的指令集差不多，除了字节码用一个字节而不是一个名字来指示这条指令。为了理解它的结构，我们将考察一个函数的字节码。考虑下面这个例子：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">cond</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="o">...</span>     <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
<span class="o">...</span>         <span class="k">return</span> <span class="s1">'yes'</span>
<span class="o">...</span>     <span class="k">else</span><span class="p">:</span>
<span class="o">...</span>         <span class="k">return</span> <span class="s1">'no'</span>
<span class="o">...</span>
</pre>


<p>Python在运行时会暴露一大批内部信息，并且我们可以通过REPL直接访问这些信息。对于函数对象<code>cond</code>，<code>cond.__code__</code>是与其关联的code object，而<code>cond.__code__.co_code</code>就是它的字节码。当你写Python代码时，你永远也不会想直接使用这些属性，但是这可以让我们做出各种恶作剧，同时也可以看看内部机制。</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">cond</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_code</span>  <span class="c1"># the bytecode as raw bytes</span>
<span class="sa">b</span><span class="s1">'d</span><span class="se">\x01\x00</span><span class="s1">}</span><span class="se">\x00\x00</span><span class="s1">|</span><span class="se">\x00\x00</span><span class="s1">d</span><span class="se">\x02\x00</span><span class="s1">k</span><span class="se">\x00\x00</span><span class="s1">r</span><span class="se">\x16\x00</span><span class="s1">d</span><span class="se">\x03\x00</span><span class="s1">Sd</span><span class="se">\x04\x00</span><span class="s1">Sd</span><span class="se">\x00</span>
   \<span class="n">x00S</span><span class="s1">'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="n">cond</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_code</span><span class="p">)</span>  <span class="c1"># the bytecode as numbers</span>
<span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">124</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">107</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> 
 <span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">83</span><span class="p">]</span>
</pre>


<p>当我们直接输出这个字节码，它看起来完全无法理解 --- 唯一我们了解的是它是一串字节。很幸运，我们有一个很强大的工具可以用：Python标准库中的<code>dis</code>模块。</p>
<p><code>dis</code>是一个字节码反汇编器。反汇编器以为机器而写的底层代码作为输入，比如汇编代码和字节码，然后以人类可读的方式输出。当我们运行<code>dis.dis</code>, 它输出每个字节码的解释。</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
  <span class="mi">2</span>           <span class="mi">0</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
              <span class="mi">3</span> <span class="n">STORE_FAST</span>               <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>

  <span class="mi">3</span>           <span class="mi">6</span> <span class="n">LOAD_FAST</span>                <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
              <span class="mi">9</span> <span class="n">LOAD_CONST</span>               <span class="mi">2</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
             <span class="mi">12</span> <span class="n">COMPARE_OP</span>               <span class="mi">0</span> <span class="p">(</span><span class="o">&lt;</span><span class="p">)</span>
             <span class="mi">15</span> <span class="n">POP_JUMP_IF_FALSE</span>       <span class="mi">22</span>

  <span class="mi">4</span>          <span class="mi">18</span> <span class="n">LOAD_CONST</span>               <span class="mi">3</span> <span class="p">(</span><span class="s1">'yes'</span><span class="p">)</span>
             <span class="mi">21</span> <span class="n">RETURN_VALUE</span>

  <span class="mi">6</span>     <span class="o">&gt;&gt;</span>   <span class="mi">22</span> <span class="n">LOAD_CONST</span>               <span class="mi">4</span> <span class="p">(</span><span class="s1">'no'</span><span class="p">)</span>
             <span class="mi">25</span> <span class="n">RETURN_VALUE</span>
             <span class="mi">26</span> <span class="n">LOAD_CONST</span>               <span class="mi">0</span> <span class="p">(</span><span class="bp">None</span><span class="p">)</span>
             <span class="mi">29</span> <span class="n">RETURN_VALUE</span>
</pre>


<p>这些都是什么意思？让我们以第一条指令<code>LOAD_CONST</code>为例子。第一列的数字（<code>2</code>）表示对应源代码的行数。第二列的数字是字节码的索引，告诉我们指令<code>LOAD_CONST</code>在0位置。第三列是指令本身对应的人类可读的名字。如果第四列存在，它表示指令的参数。如果第5列存在，它是一个关于参数是什么的提示。</p>
<p>考虑这个字节码的前几个字节：[100, 1, 0, 125, 0, 0]。这6个字节表示两条带参数的指令。我们可以使用<code>dis.opname</code>，一个字节到可读字符串的映射，来找到指令100和指令125代表是什么：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">opname</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
<span class="s1">'LOAD_CONST'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">opname</span><span class="p">[</span><span class="mi">125</span><span class="p">]</span>
<span class="s1">'STORE_FAST'</span>
</pre>


<p>第二和第三个字节 --- 1 ，0 ---是<code>LOAD_CONST</code>的参数，第五和第六个字节 --- 0，0 --- 是<code>STORE_FAST</code>的参数。就像我们前面的小例子，<code>LOAD_CONST</code>需要知道的到哪去找常量，<code>STORE_FAST</code>需要找到名字。（Python的<code>LOAD_CONST</code>和我们小例子中的<code>LOAD_VALUE</code>一样，<code>LOAD_FAST</code>和<code>LOAD_NAME</code>一样）。所以这六个字节代表第一行源代码<code>x = 3</code>.(为什么用两个字节表示指令的参数？如果Python使用一个字节，每个code object你只能有256个常量/名字，而用两个字节，就增加到了256的平方，65536个）。</p>
<h4>Conditionals and Loops</h4>
<p>到目前为止，我们的解释器只能一条接着一条的执行指令。这有个问题，我们经常会想多次执行某个指令，或者在特定的条件下跳过它们。为了可以写循环和分支结构，解释器必须能够在指令中跳转。在某种程度上，Python在字节码中使用<code>GOTO</code>语句来处理循环和分支！让我们再看一个<code>cond</code>函数的反汇编结果：</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
  <span class="mi">2</span>           <span class="mi">0</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
              <span class="mi">3</span> <span class="n">STORE_FAST</span>               <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>

  <span class="mi">3</span>           <span class="mi">6</span> <span class="n">LOAD_FAST</span>                <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
              <span class="mi">9</span> <span class="n">LOAD_CONST</span>               <span class="mi">2</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
             <span class="mi">12</span> <span class="n">COMPARE_OP</span>               <span class="mi">0</span> <span class="p">(</span><span class="o">&lt;</span><span class="p">)</span>
             <span class="mi">15</span> <span class="n">POP_JUMP_IF_FALSE</span>       <span class="mi">22</span>

  <span class="mi">4</span>          <span class="mi">18</span> <span class="n">LOAD_CONST</span>               <span class="mi">3</span> <span class="p">(</span><span class="s1">'yes'</span><span class="p">)</span>
             <span class="mi">21</span> <span class="n">RETURN_VALUE</span>

  <span class="mi">6</span>     <span class="o">&gt;&gt;</span>   <span class="mi">22</span> <span class="n">LOAD_CONST</span>               <span class="mi">4</span> <span class="p">(</span><span class="s1">'no'</span><span class="p">)</span>
             <span class="mi">25</span> <span class="n">RETURN_VALUE</span>
             <span class="mi">26</span> <span class="n">LOAD_CONST</span>               <span class="mi">0</span> <span class="p">(</span><span class="bp">None</span><span class="p">)</span>
             <span class="mi">29</span> <span class="n">RETURN_VALUE</span>
</pre>


<p>第三行的条件表达式<code>if x &lt; 5</code>被编译成四条指令：<code>LOAD_FAST</code>, <code>LOAD_CONST</code>, <code>COMPARE_OP</code>和 <code>POP_JUMP_IF_FALSE</code>。<code>x &lt; 5</code>对应加载<code>x</code>，加载5，比较这两个值。指令<code>POP_JUMP_IF_FALSE</code>完成<code>if</code>语句。这条指令把栈顶的值弹出，如果值为真，什么都不发生。如果值为假，解释器会跳转到另一条指令。</p>
<p>这条将被加载的指令称为跳转目标，它作为指令<code>POP_JUMP</code>的参数。这里，跳转目标是22，索引为22的指令是<code>LOAD_CONST</code>,对应源码的第6行。（<code>dis</code>用<code>&gt;&gt;</code>标记跳转目标。）如果<code>X &lt; 5</code>为假，解释器会忽略第四行（<code>return yes</code>）,直接跳转到第6行（<code>return "no"</code>）。因此解释器通过跳转指令选择性的执行指令。</p>
<p>Python的循环也依赖于跳转。在下面的字节码中，<code>while x &lt; 5</code>这一行产生了和<code>if x &lt; 10</code>几乎一样的字节码。在这两种情况下，解释器都是先执行比较，然后执行<code>POP_JUMP_IF_FALSE</code>来控制下一条执行哪个指令。第四行的最后一条字节码<code>JUMP_ABSOLUT</code>(循环体结束的地方），让解释器返回到循环开始的第9条指令处。当 <code>x &lt; 10</code>变为假，<code>POP_JUMP_IF_FALSE</code>会让解释器跳到循环的终止处，第34条指令。 </p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
<span class="o">...</span>      <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">...</span>      <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
<span class="o">...</span>          <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">...</span>      <span class="k">return</span> <span class="n">x</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
  <span class="mi">2</span>           <span class="mi">0</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
              <span class="mi">3</span> <span class="n">STORE_FAST</span>               <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>

  <span class="mi">3</span>           <span class="mi">6</span> <span class="n">SETUP_LOOP</span>              <span class="mi">26</span> <span class="p">(</span><span class="n">to</span> <span class="mi">35</span><span class="p">)</span>
        <span class="o">&gt;&gt;</span>    <span class="mi">9</span> <span class="n">LOAD_FAST</span>                <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
             <span class="mi">12</span> <span class="n">LOAD_CONST</span>               <span class="mi">2</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
             <span class="mi">15</span> <span class="n">COMPARE_OP</span>               <span class="mi">0</span> <span class="p">(</span><span class="o">&lt;</span><span class="p">)</span>
             <span class="mi">18</span> <span class="n">POP_JUMP_IF_FALSE</span>       <span class="mi">34</span>

  <span class="mi">4</span>          <span class="mi">21</span> <span class="n">LOAD_FAST</span>                <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
             <span class="mi">24</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
             <span class="mi">27</span> <span class="n">BINARY_ADD</span>
             <span class="mi">28</span> <span class="n">STORE_FAST</span>               <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
             <span class="mi">31</span> <span class="n">JUMP_ABSOLUTE</span>            <span class="mi">9</span>
        <span class="o">&gt;&gt;</span>   <span class="mi">34</span> <span class="n">POP_BLOCK</span>

  <span class="mi">5</span>     <span class="o">&gt;&gt;</span>   <span class="mi">35</span> <span class="n">LOAD_FAST</span>                <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
             <span class="mi">38</span> <span class="n">RETURN_VALUE</span>
</pre>


<h4>Explore Bytecode</h4>
<p>我希望你用<code>dis.dis</code>来试试你自己写的函数。一些有趣的问题值得探索：</p>
<ul>
<li>对解释器而言for循环和while循环有什么不同？</li>
<li>能不能写出两个不同函数，却能产生相同的字节码?</li>
<li>
<code>elif</code>是怎么工作的？列表推导呢？</li>
</ul>
<h3>Frames</h3>
<p>到目前为止，我们已经知道了Python虚拟机是一个栈机器。它能顺序执行指令，在指令间跳转，压入或弹出栈值。但是这和我们期望的解释器还有一定距离。在前面的那个例子中，最后一条指令是<code>RETURN_VALUE</code>,它和<code>return</code>语句相对应。但是它返回到哪里去呢？</p>
<p>为了回答这个问题，我们必须再增加一层复杂性：frame。一个frame是一些信息的集合和代码的执行上下文。frames在Python代码执行时动态的创建和销毁。每个frame对应函数的一次调用。--- 所以每个frame只有一个code object与之关联，而一个code object可以有多个frame。比如你有一个函数递归的调用自己10次，这会产生11个frame，每次调用对应一个，再加上启动模块对应的一个frame。总的来说，Python程序的每个作用域有一个frame，比如，模块，函数，类。</p>
<p>Frame存在于_调用栈_中，一个和我们之前讨论的完全不同的栈。（你最熟悉的栈就是调用栈，就是你经常看到的异常回溯，每个以"File 'program.py'"开始的回溯对应一个frame。）解释器在执行字节码时操作的栈，我们叫它_数据栈_。其实还有第三个栈，叫做_块栈_，用于特定的控制流块，比如循环和异常处理。调用栈中的每个frame都有它自己的数据栈和块栈。</p>
<p>让我们用一个具体的例子来说明。假设Python解释器执行到标记为3的地方。解释器正在<code>foo</code>函数的调用中，它接着调用<code>bar</code>。下面是frame调用栈，块栈和数据栈的示意图。我们感兴趣的是解释器先从最底下的<code>foo()</code>开始，接着执行<code>foo</code>的函数体，然后到达<code>bar</code>。</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">z</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">3</span>     <span class="c1"># &lt;--- (3) ... and the interpreter is here.</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">z</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">...</span>     <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">bar</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># &lt;--- (2) ... which is returning a call to bar ...</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">foo</span><span class="p">()</span>             <span class="c1"># &lt;--- (1) We're in the middle of a call to foo ...</span>
<span class="mi">3</span>
</pre>


<p>\aosafigure[240pt]{interpreter-images/interpreter-callstack.png}{The call stack}{500l.interpreter.callstack}</p>
<p>现在，解释器在<code>bar</code>函数的调用中。调用栈中有3个frame：一个对应于模块层，一个对应函数<code>foo</code>,别一个对应函数<code>bar</code>。(\aosafigref{500l.interpreter.callstack}.)一旦<code>bar</code>返回，与它对应的frame就会从调用栈中弹出并丢弃。</p>
<p>字节码指令<code>RETURN_VALUE</code>告诉解释器在frame间传递一个值。首先，它把位于调用栈栈顶的frame中的数据栈的栈顶值弹出。然后把整个frame弹出丢弃。最后把这个值压到下一个frame的数据栈中。</p>
<p>当Ned Batchelder和我在写Byterun时，很长一段时间我们的实现中一直有个重大的错误。我们整个虚拟机中只有一个数据栈，而不是每个frame都有一个。我们写了很多测试代码，同时在Byterun和真正的Python上运行，希望得到一致结果。我们几乎通过了所有测试，只有一样东西不能通过，那就是生成器。最后，通过仔细的阅读CPython的源码，我们发现了错误所在<sup id="fnref-thanks"><a class="footnote-ref" href="posts/python-interpreter/#fn-thanks">1</a></sup>。把数据栈移到每个frame就解决了这个问题。</p>
<p>回头在看看这个bug，我惊讶的发现Python真的很少依赖于每个frame有一个数据栈这个特性。在Python中几乎所有的操作都会清空数据栈，所以所有的frame公用一个数据栈是没问题的。在上面的例子中，当<code>bar</code>执行完后，它的数据栈为空。即使<code>foo</code>公用这一个栈，它的值也不会受影响。然而，对应生成器，一个关键的特点是它能暂停一个frame的执行，返回到其他的frame，一段时间后它能返回到原来的frame，并以它离开时的相同状态继续执行。</p>
<h3>Byterun</h3>
<p>现在我们有足够的Python解释器的知识背景去考察Byterun。</p>
<p>Byterun中有四种对象。</p>
<ul>
<li>
<code>VirtualMachine</code>类，它管理高层结构，frame调用栈，指令到操作的映射。这是一个比前面<code>Inteprter</code>对象更复杂的版本。</li>
<li>
<code>Frame</code>类，每个<code>Frame</code>类都有一个code object，并且管理者其他一些必要的状态信息，全局和局部命名空间，指向调用它的frame的指针和最后执行的字节码指令。 </li>
<li>
<code>Function</code>类，它被用来代替真正的Python函数。回想一下，调用函数时会创建一个新的frame。我们自己实现<code>Function</code>，所以我们控制新frame的创建。</li>
<li>
<code>Block</code>类，它只是包装了block的3个属性。（block的细节不是解释器的核心，我们不会花时间在它身上，把它列在这里，是因为Byterun需要它。）</li>
</ul>
<h4>The <code>VirtualMachine</code> Class</h4>
<p>程序运行时只有一个<code>VirtualMachine</code>被创建，因为我们只有一个解释器。<code>VirtualMachine</code>保存调用栈，异常状态，在frame中传递的返回值。它的入口点是<code>run_code</code>方法，它以编译后的code object为参数，以创建一个frame为开始，然后运行这个frame。这个frame可能再创建出新的frame；调用栈随着程序的运行增长缩短。当第一个frame返回时，执行结束。</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">VirtualMachineError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">VirtualMachine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># The call stack of frames.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># The current frame.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_exception</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">run_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">global_names</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">local_names</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">""" An entry point to execute code using the virtual machine."""</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_frame</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">global_names</span><span class="o">=</span><span class="n">global_names</span><span class="p">,</span> 
                                <span class="n">local_names</span><span class="o">=</span><span class="n">local_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
</pre>


<h4>The <code>Frame</code> Class</h4>
<p>接下来，我们来写<code>Frame</code>对象。frame是一个属性的集合，它没有任何方法。前面提到过，这些属性包括由编译器生成的code object；局部，全局和内置命名空间；前一个frame的引用；一个数据栈；一个块栈；最后执行的指令指针。（对于内置命名空间我们需要多做一点工作，Python在不同模块中对这个命名空间有不同的处理；但这个细节对我们的虚拟机不重要。）</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Frame</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code_obj</span><span class="p">,</span> <span class="n">global_names</span><span class="p">,</span> <span class="n">local_names</span><span class="p">,</span> <span class="n">prev_frame</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code_obj</span> <span class="o">=</span> <span class="n">code_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_names</span> <span class="o">=</span> <span class="n">global_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_names</span> <span class="o">=</span> <span class="n">local_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_frame</span> <span class="o">=</span> <span class="n">prev_frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">prev_frame</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">builtin_names</span> <span class="o">=</span> <span class="n">prev_frame</span><span class="o">.</span><span class="n">builtin_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">builtin_names</span> <span class="o">=</span> <span class="n">local_names</span><span class="p">[</span><span class="s1">'__builtins__'</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">builtin_names</span><span class="p">,</span> <span class="s1">'__dict__'</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">builtin_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">builtin_names</span><span class="o">.</span><span class="vm">__dict__</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">last_instruction</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_stack</span> <span class="o">=</span> <span class="p">[]</span>
</pre>


<p>接着，我们在虚拟机中增加对frame的操作。这有3个帮助函数：一个创建新的frame的方法，和压栈和出栈的方法。第四个函数，<code>run_frame</code>,完成执行frame的主要工作，待会我们再讨论这个方法。</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">VirtualMachine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="p">[</span><span class="o">...</span> <span class="n">snip</span> <span class="o">...</span><span class="p">]</span>

    <span class="c1"># Frame manipulation</span>
    <span class="k">def</span> <span class="nf">make_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">callargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">global_names</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">local_names</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">global_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">local_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">local_names</span> <span class="o">=</span> <span class="n">global_names</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">:</span>
            <span class="n">global_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">global_names</span>
            <span class="n">local_names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">global_names</span> <span class="o">=</span> <span class="n">local_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">'__builtins__'</span><span class="p">:</span> <span class="n">__builtins__</span><span class="p">,</span>
                <span class="s1">'__name__'</span><span class="p">:</span> <span class="s1">'__main__'</span><span class="p">,</span>
                <span class="s1">'__doc__'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
                <span class="s1">'__package__'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="n">local_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">callargs</span><span class="p">)</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">global_names</span><span class="p">,</span> <span class="n">local_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">frame</span>

    <span class="k">def</span> <span class="nf">push_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span>

    <span class="k">def</span> <span class="nf">pop_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">run_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
        <span class="c1"># we'll come back to this shortly</span>
</pre>


<h4>The <code>Function</code> Class</h4>
<p><code>Function</code>的实现有点扭曲，但是大部分的细节对理解解释器不重要。重要的是当调用函数时 --- <code>__call__</code>方法被调用 --- 它创建一个新的<code>Frame</code>并运行它。</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Create a realistic function object, defining the things the interpreter expects.</span>
<span class="sd">    """</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">'func_code'</span><span class="p">,</span> <span class="s1">'func_name'</span><span class="p">,</span> <span class="s1">'func_defaults'</span><span class="p">,</span> <span class="s1">'func_globals'</span><span class="p">,</span>
        <span class="s1">'func_locals'</span><span class="p">,</span> <span class="s1">'func_dict'</span><span class="p">,</span> <span class="s1">'func_closure'</span><span class="p">,</span>
        <span class="s1">'__name__'</span><span class="p">,</span> <span class="s1">'__dict__'</span><span class="p">,</span> <span class="s1">'__doc__'</span><span class="p">,</span>
        <span class="s1">'_vm'</span><span class="p">,</span> <span class="s1">'_func'</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">globs</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">closure</span><span class="p">,</span> <span class="n">vm</span><span class="p">):</span>
        <span class="sd">"""You don't need to follow this closely to understand the interpreter."""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vm</span> <span class="o">=</span> <span class="n">vm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_code</span> <span class="o">=</span> <span class="n">code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">code</span><span class="o">.</span><span class="n">co_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_defaults</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_globals</span> <span class="o">=</span> <span class="n">globs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_locals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vm</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_closure</span> <span class="o">=</span> <span class="n">closure</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">co_consts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">code</span><span class="o">.</span><span class="n">co_consts</span> <span class="k">else</span> <span class="bp">None</span>

        <span class="c1"># Sometimes, we need a real Python function.  This is for that.</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">'argdefs'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_defaults</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">closure</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s1">'closure'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">make_cell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">closure</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">globs</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""When calling a Function, make a new frame and run it."""</span>
        <span class="n">callargs</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getcallargs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Use callargs to provide a mapping of arguments: values to pass into the new </span>
        <span class="c1"># frame.</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vm</span><span class="o">.</span><span class="n">make_frame</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func_code</span><span class="p">,</span> <span class="n">callargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_globals</span><span class="p">,</span> <span class="p">{}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vm</span><span class="o">.</span><span class="n">run_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">make_cell</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">"""Create a real Python closure and grab a cell."""</span>
    <span class="c1"># Thanks to Alex Gaynor for help with this bit of twistiness.</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span><span class="p">)(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fn</span><span class="o">.</span><span class="vm">__closure__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre>


<p>接着，回到<code>VirtualMachine</code>对象，我们对数据栈的操作也增加一些帮助方法。字节码操作的栈总是在当前frame的数据栈。这些帮助函数让我们能实现<code>POP_TOP</code>,<code>LOAD_FAST</code>字节码,并且让其他操作栈的指令可读性更高。</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">VirtualMachine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="p">[</span><span class="o">...</span> <span class="n">snip</span> <span class="o">...</span><span class="p">]</span>

    <span class="c1"># Data stack manipulation</span>
    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">vals</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">popn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">"""Pop a number of values from the value stack.</span>
<span class="sd">        A list of `n` values is returned, the deepest value first.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
</pre>


<p>在我们运行frame之前，我们还需两个方法。</p>
<p>第一个方法，<code>parse_byte_and_args</code>,以一个字节码为输入，先检查它是否有参数，如果有，就解析它的参数。这个方法同时也更新frame的<code>last_instruction</code>属性，它指向最后执行的指令。一条没有参数的指令只有一个字节长度，而有参数的字节有3个字节长。参数的意义依赖于指令是什么。比如，前面说过，指令<code>POP_JUMP_IF_FALSE</code>,它的参数指的是跳转目标。<code>BUILD_LIST</code>, 它的参数是列表的个数。<code>LOAD_CONST</code>,它的参数是常量的索引。</p>
<p>一些指令用简单的数字作为参数。对于另一些，虚拟机需要一点努力去发现它含意。标准库中的<code>dis</code>模块中有一个备忘单，它解释什么参数有什么意思，这让我们的代码更加简洁。比如，列表<code>dis.hasname</code>告诉我们<code>LOAD_NAME</code>, <code>IMPORT_NAME</code>,<code>LOAD_GLOBAL</code>,以及另外的9个指令都有同样的意思：名字列表的索引。</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">VirtualMachine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="p">[</span><span class="o">...</span> <span class="n">snip</span> <span class="o">...</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">parse_byte_and_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span>
        <span class="n">opoffset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">last_instruction</span>
        <span class="n">byteCode</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">code_obj</span><span class="o">.</span><span class="n">co_code</span><span class="p">[</span><span class="n">opoffset</span><span class="p">]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">last_instruction</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">byte_name</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="n">opname</span><span class="p">[</span><span class="n">byteCode</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">byteCode</span> <span class="o">&gt;=</span> <span class="n">dis</span><span class="o">.</span><span class="n">HAVE_ARGUMENT</span><span class="p">:</span>
            <span class="c1"># index into the bytecode</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">code_obj</span><span class="o">.</span><span class="n">co_code</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">last_instruction</span><span class="p">:</span><span class="n">f</span><span class="o">.</span><span class="n">last_instruction</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>  
            <span class="n">f</span><span class="o">.</span><span class="n">last_instruction</span> <span class="o">+=</span> <span class="mi">2</span>   <span class="c1"># advance the instruction pointer</span>
            <span class="n">arg_val</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">256</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">byteCode</span> <span class="ow">in</span> <span class="n">dis</span><span class="o">.</span><span class="n">hasconst</span><span class="p">:</span>   <span class="c1"># Look up a constant</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">code_obj</span><span class="o">.</span><span class="n">co_consts</span><span class="p">[</span><span class="n">arg_val</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">byteCode</span> <span class="ow">in</span> <span class="n">dis</span><span class="o">.</span><span class="n">hasname</span><span class="p">:</span>  <span class="c1"># Look up a name</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">code_obj</span><span class="o">.</span><span class="n">co_names</span><span class="p">[</span><span class="n">arg_val</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">byteCode</span> <span class="ow">in</span> <span class="n">dis</span><span class="o">.</span><span class="n">haslocal</span><span class="p">:</span> <span class="c1"># Look up a local name</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">code_obj</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">[</span><span class="n">arg_val</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">byteCode</span> <span class="ow">in</span> <span class="n">dis</span><span class="o">.</span><span class="n">hasjrel</span><span class="p">:</span>  <span class="c1"># Calculate a relative jump</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">last_instruction</span> <span class="o">+</span> <span class="n">arg_val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">arg_val</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">byte_name</span><span class="p">,</span> <span class="n">argument</span>
</pre>


<p>下一个方法是<code>dispatch</code>,它查看给定的指令并执行相应的操作。在CPython中，这个分派函数用一个巨大的switch语句实现，有超过1500行的代码。幸运的是，我们用的是Python，我们的代码会简洁的多。我们会为每一个字节码名字定义一个方法，然后用<code>getattr</code>来查找。就像我们前面的小解释器一样，如果一条指令叫做<code>FOO_BAR</code>，那么它对应的方法就是<code>byte_FOO_BAR</code>。现在，我们先把这些方法当做一个黑盒子。每个指令方法都会返回<code>None</code>或者一个字符串<code>why</code>,有些情况下虚拟机需要这个额外<code>why</code>信息。这些指令方法的返回值，仅作为解释器状态的内部指示，千万不要和执行frame的返回值相混淆。</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">VirtualMachine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="p">[</span><span class="o">...</span> <span class="n">snip</span> <span class="o">...</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byte_name</span><span class="p">,</span> <span class="n">argument</span><span class="p">):</span>
        <span class="sd">""" Dispatch by bytename to the corresponding methods.</span>
<span class="sd">        Exceptions are caught and set on the virtual machine."""</span>

        <span class="c1"># When later unwinding the block stack,</span>
        <span class="c1"># we need to keep track of why we are doing it.</span>
        <span class="n">why</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bytecode_fn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'byte_</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">byte_name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bytecode_fn</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">byte_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'UNARY_'</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unaryOperator</span><span class="p">(</span><span class="n">byte_name</span><span class="p">[</span><span class="mi">6</span><span class="p">:])</span>
                <span class="k">elif</span> <span class="n">byte_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'BINARY_'</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">binaryOperator</span><span class="p">(</span><span class="n">byte_name</span><span class="p">[</span><span class="mi">7</span><span class="p">:])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">VirtualMachineError</span><span class="p">(</span>
                        <span class="s2">"unsupported bytecode type: </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="n">byte_name</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">why</span> <span class="o">=</span> <span class="n">bytecode_fn</span><span class="p">(</span><span class="o">*</span><span class="n">argument</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># deal with exceptions encountered while executing the op.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_exception</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">None</span><span class="p">,)</span>
            <span class="n">why</span> <span class="o">=</span> <span class="s1">'exception'</span>

        <span class="k">return</span> <span class="n">why</span>

    <span class="k">def</span> <span class="nf">run_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="sd">"""Run a frame until it returns (somehow).</span>
<span class="sd">        Exceptions are raised, the return value is returned.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">byte_name</span><span class="p">,</span> <span class="n">arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_byte_and_args</span><span class="p">()</span>

            <span class="n">why</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">byte_name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">)</span>

            <span class="c1"># Deal with any block management we need to do</span>
            <span class="k">while</span> <span class="n">why</span> <span class="ow">and</span> <span class="n">frame</span><span class="o">.</span><span class="n">block_stack</span><span class="p">:</span>
                <span class="n">why</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manage_block_stack</span><span class="p">(</span><span class="n">why</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">why</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pop_frame</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">why</span> <span class="o">==</span> <span class="s1">'exception'</span><span class="p">:</span>
            <span class="n">exc</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">tb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_exception</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">exc</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">e</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="n">tb</span>
            <span class="k">raise</span> <span class="n">e</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_value</span>
</pre>


<h4>The <code>Block</code> Class</h4>
<p>在我们完成每个字节码方法前，我们简单的讨论一下块。一个块被用于某种控制流，特别是异常处理和循环。它负责保证当操作完成后数据栈处于正确的状态。比如，在一个循环中，一个特殊的迭代器会存在栈中，当循环完成时它从栈中弹出。解释器需要检查循环仍在继续还是已经停止。</p>
<p>为了跟踪这些额外的信息，解释器设置了一个标志来指示它的状态。我们用一个变量<code>why</code>实现这个标志，它可以是<code>None</code>或者是下面几个字符串这一，<code>"continue"</code>, <code>"break"</code>,<code>"excption"</code>,<code>return</code>。他们指示对块栈和数据栈进行什么操作。回到我们迭代器的例子，如果块栈的栈顶是一个<code>loop</code>块，<code>why</code>是<code>continue</code>,迭代器就因该保存在数据栈上，不是如果<code>why</code>是<code>break</code>,迭代器就会被弹出。</p>
<p>块操作的细节比较精细，我们不会花时间在这上面，但是有兴趣的读者值得仔细的看看。</p>
<pre class="code literal-block"><span></span><span class="n">Block</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">"Block"</span><span class="p">,</span> <span class="s2">"type, handler, stack_height"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">VirtualMachine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="p">[</span><span class="o">...</span> <span class="n">snip</span> <span class="o">...</span><span class="p">]</span>

    <span class="c1"># Block stack manipulation</span>
    <span class="k">def</span> <span class="nf">push_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b_type</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">level</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">block_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Block</span><span class="p">(</span><span class="n">b_type</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">stack_height</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">pop_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">block_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">unwind_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
        <span class="sd">"""Unwind the values on the data stack corresponding to a given block."""</span>
        <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">'except-handler'</span><span class="p">:</span>
            <span class="c1"># The exception itself is on the stack as type, value, and traceback.</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="mi">3</span>  
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">block</span><span class="o">.</span><span class="n">level</span> <span class="o">+</span> <span class="n">offset</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">'except-handler'</span><span class="p">:</span>
            <span class="n">traceback</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">exctype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_exception</span> <span class="o">=</span> <span class="n">exctype</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span>

    <span class="k">def</span> <span class="nf">manage_block_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">why</span><span class="p">):</span>
        <span class="sd">""" """</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">block_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">'loop'</span> <span class="ow">and</span> <span class="n">why</span> <span class="o">==</span> <span class="s1">'continue'</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_value</span><span class="p">)</span>
            <span class="n">why</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">why</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pop_block</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unwind_block</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">'loop'</span> <span class="ow">and</span> <span class="n">why</span> <span class="o">==</span> <span class="s1">'break'</span><span class="p">:</span>
            <span class="n">why</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">handler</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">why</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'setup-except'</span><span class="p">,</span> <span class="s1">'finally'</span><span class="p">]</span> <span class="ow">and</span> <span class="n">why</span> <span class="o">==</span> <span class="s1">'exception'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_block</span><span class="p">(</span><span class="s1">'except-handler'</span><span class="p">)</span>
            <span class="n">exctype</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">tb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_exception</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">exctype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">exctype</span><span class="p">)</span> <span class="c1"># yes, twice</span>
            <span class="n">why</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">handler</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">why</span>

        <span class="k">elif</span> <span class="n">block</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">'finally'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">why</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'return'</span><span class="p">,</span> <span class="s1">'continue'</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_value</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">why</span><span class="p">)</span>

            <span class="n">why</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">handler</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">why</span>
        <span class="k">return</span> <span class="n">why</span>
</pre>


<h3>The Instructions</h3>
<p>剩下了的就是完成那些指令方法了：<code>byte_LOAD_FAST</code>,<code>byte_BINARY_MODULO</code>等等。而这些指令的实现并不是很有趣，这里我们只展示了一小部分，完整的实现在这儿https://github.com/nedbat/byterun。（足够执行我们前面所述的所有代码了。）</p>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">VirtualMachine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="p">[</span><span class="o">...</span> <span class="n">snip</span> <span class="o">...</span><span class="p">]</span>

    <span class="c1">## Stack manipulation</span>

    <span class="k">def</span> <span class="nf">byte_LOAD_CONST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">const</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_POP_TOP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="c1">## Names</span>
    <span class="k">def</span> <span class="nf">byte_LOAD_NAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_globals</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_globals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_builtins</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">f_builtins</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">"name '</span><span class="si">%s</span><span class="s2">' is not defined"</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_STORE_NAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">byte_LOAD_FAST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">UnboundLocalError</span><span class="p">(</span>
                <span class="s2">"local variable '</span><span class="si">%s</span><span class="s2">' referenced before assignment"</span> <span class="o">%</span> <span class="n">name</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_STORE_FAST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">f_locals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">byte_LOAD_GLOBAL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">f_globals</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">f_globals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">f_builtins</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">f_builtins</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">"global name '</span><span class="si">%s</span><span class="s2">' is not defined"</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="c1">## Operators</span>

    <span class="n">BINARY_OPERATORS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">'POWER'</span><span class="p">:</span>    <span class="nb">pow</span><span class="p">,</span>
        <span class="s1">'MULTIPLY'</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span>
        <span class="s1">'FLOOR_DIVIDE'</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">,</span>
        <span class="s1">'TRUE_DIVIDE'</span><span class="p">:</span>  <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span>
        <span class="s1">'MODULO'</span><span class="p">:</span>   <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span>
        <span class="s1">'ADD'</span><span class="p">:</span>      <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
        <span class="s1">'SUBTRACT'</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
        <span class="s1">'SUBSCR'</span><span class="p">:</span>   <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span>
        <span class="s1">'LSHIFT'</span><span class="p">:</span>   <span class="n">operator</span><span class="o">.</span><span class="n">lshift</span><span class="p">,</span>
        <span class="s1">'RSHIFT'</span><span class="p">:</span>   <span class="n">operator</span><span class="o">.</span><span class="n">rshift</span><span class="p">,</span>
        <span class="s1">'AND'</span><span class="p">:</span>      <span class="n">operator</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span>
        <span class="s1">'XOR'</span><span class="p">:</span>      <span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">,</span>
        <span class="s1">'OR'</span><span class="p">:</span>       <span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">binaryOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">BINARY_OPERATORS</span><span class="p">[</span><span class="n">op</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

    <span class="n">COMPARE_OPERATORS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">lt</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">y</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">y</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">byte_COMPARE_OP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opnum</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">COMPARE_OPERATORS</span><span class="p">[</span><span class="n">opnum</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

    <span class="c1">## Attributes and indexing</span>

    <span class="k">def</span> <span class="nf">byte_LOAD_ATTR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_STORE_ATTR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="c1">## Building</span>

    <span class="k">def</span> <span class="nf">byte_BUILD_LIST</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="n">elts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popn</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">elts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_BUILD_MAP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">({})</span>

    <span class="k">def</span> <span class="nf">byte_STORE_MAP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">the_map</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">the_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">the_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_LIST_APPEND</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">the_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="n">count</span><span class="p">]</span> <span class="c1"># peek</span>
        <span class="n">the_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="c1">## Jumps</span>

    <span class="k">def</span> <span class="nf">byte_JUMP_FORWARD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jump</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="n">jump</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_JUMP_ABSOLUTE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jump</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="n">jump</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_POP_JUMP_IF_TRUE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jump</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="n">jump</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_POP_JUMP_IF_FALSE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jump</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="n">jump</span><span class="p">)</span>

    <span class="c1">## Blocks</span>

    <span class="k">def</span> <span class="nf">byte_SETUP_LOOP</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push_block</span><span class="p">(</span><span class="s1">'loop'</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_GET_ITER</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">byte_FOR_ITER</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jump</span><span class="p">):</span>
        <span class="n">iterobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iterobj</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="n">jump</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_BREAK_LOOP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">'break'</span>

    <span class="k">def</span> <span class="nf">byte_POP_BLOCK</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop_block</span><span class="p">()</span>

    <span class="c1">## Functions</span>

    <span class="k">def</span> <span class="nf">byte_MAKE_FUNCTION</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">argc</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popn</span><span class="p">(</span><span class="n">argc</span><span class="p">)</span>
        <span class="n">globs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">f_globals</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">globs</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_CALL_FUNCTION</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">lenKw</span><span class="p">,</span> <span class="n">lenPos</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span> <span class="c1"># KWargs not supported here</span>
        <span class="n">posargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popn</span><span class="p">(</span><span class="n">lenPos</span><span class="p">)</span>

        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">posargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">retval</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">byte_RETURN_VALUE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="s2">"return"</span>
</pre>


<h3>Dynamic Typing: What the Compiler Doesn't Know</h3>
<p>你可能听过Python是一种动态语言 --- 是它是动态类型的。在我们建造解释器的过程中，已经透露出这样的信息。</p>
<p>动态的一个意思是很多工作在运行时完成。前面我们看到Python的编译器没有很多关于代码真正做什么的信息。举个例子，考虑下面这个简单的函数<code>mod</code>。它取两个参数，返回它们的模运算值。从它的字节码中，我们看到变量<code>a</code>和<code>b</code>首先被加载，然后字节码<code>BINAY_MODULO</code>完成这个模运算。</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">mod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="o">...</span>    <span class="k">return</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
  <span class="mi">2</span>           <span class="mi">0</span> <span class="n">LOAD_FAST</span>                <span class="mi">0</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
              <span class="mi">3</span> <span class="n">LOAD_FAST</span>                <span class="mi">1</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span>
              <span class="mi">6</span> <span class="n">BINARY_MODULO</span>
              <span class="mi">7</span> <span class="n">RETURN_VALUE</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mod</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">4</span>
</pre>


<p>计算19 % 5得4，--- 一点也不奇怪。如果我们用不同类的参数呢？</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">mod</span><span class="p">(</span><span class="s2">"by</span><span class="si">%s</span><span class="s2">de"</span><span class="p">,</span> <span class="s2">"teco"</span><span class="p">)</span>
<span class="s1">'bytecode'</span>
</pre>


<p>刚才发生了什么？你可能见过这样的语法，格式化字符串。</p>
<pre class="code literal-block"><span></span>&gt;&gt;&gt; print("by%sde" % "teco")
bytecode
</pre>


<p>用符号<code>%</code>去格式化字符串会调用字节码<code>BUNARY_MODULO</code>.它取栈顶的两个值求模，不管这两个值是字符串，数字或是你自己定义的类的实例。字节码在函数编译时生成（或者说，函数定义时）相同的字节码会用于不同类的参数。</p>
<p>Python的编译器关于字节码的功能知道的很少。而取决于解释器来决定<code>BINAYR_MODULO</code>应用于什么类型的对象并完成正确的操作。这就是为什么Python被描述为_动态类型_：直到运行前你不必知道这个函数参数的类型。相反，在一个静态类型语言中，程序员需要告诉编译器参数的类型是什么（或者编译器自己推断出参数的类型。）</p>
<p>编译器的无知是优化Python的一个挑战 --- 只看字节码，而不真正运行它，你就不知道每条字节码在干什么！你可以定义一个类，实现<code>__mod__</code>方法，当你对这个类的实例使用<code>%</code>时，Python就会自动调用这个方法。所以，<code>BINARY_MODULO</code>其实可以运行任何代码。</p>
<p>看看下面的代码，第一个<code>a % b</code>看起来没有用。</p>
<pre class="code literal-block"><span></span><span class="k">def</span> <span class="nf">mod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">%</span><span class="n">b</span>
</pre>


<p>不幸的是，对这段代码进行静态分析 --- 不运行它 --- 不能确定第一个<code>a % b</code>没有做任何事。用 <code>%</code>调用<code>__mod__</code>可能会写一个文件，或是和程序的其他部分交互，或者其他任何可以在Python中完成的事。很难优化一个你不知道它会做什么的函数。在Russell Power和Alex Rubinsteyn的优秀论文中写道，“我们可以用多快的速度解释Python？”，他们说，“在普遍缺乏类型信息下，每条指令必须被看作一个<code>INVOKE_ARBITRARY_METHOD</code>。”</p>
<h3>Conclusion</h3>
<p>Byterun是一个比CPython容易理解的简洁的Python解释器。Byterun复制了CPython的主要结构：一个基于栈的指令集称为字节码，它们顺序执行或在指令间跳转，向栈中压入和从中弹出数据。解释器随着函数和生成器的调用和返回，动态的创建，销毁frame，并在frame间跳转。Byterun也有着和真正解释器一样的限制：因为Python使用动态类型，解释器必须在运行时决定指令的正确行为。</p>
<p>我鼓励你去反汇编你的程序，然后用Byterun来运行。你很快会发现这个缩短版的Byterun所没有实现的指令。完整的实现在https://github.com/nedbat/byterun，或者仔细阅读真正的CPython解释器<code>ceval.c</code>,你也可以实现自己的解释器！</p>
<h3>Acknowledgements</h3>
<p>Thanks to Ned Batchelder for originating this project and guiding my contributions, Michael Arntzenius for his help debugging the code and editing the prose, Leta Montopoli for her edits, and the entire Recurse Center community for their support and interest. Any errors are my own.</p>
<div class="footnote">
<hr>
<ol>
<li id="fn-thanks">
<p>感谢 Michael Arntzenius 对这个bug的洞悉。 <a class="footnote-backref" href="posts/python-interpreter/#fnref-thanks" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
</ol>
</div>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posts/a-template-engine/" class="u-url">A Template Engine</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Tao Qingyun
            </span></p>
            <p class="dateline"><a href="posts/a-template-engine/" rel="bookmark"><time class="published dt-published" datetime="2015-10-09T11:32:25+08:00" title="2015-10-09 11:32">2015-10-09 11:32</time></a></p>
                <p class="commentline">
        
    <a href="posts/a-template-engine/#disqus_thread" data-disqus-identifier="cache/posts/a-template-engine.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<h3>Introduction</h3>
<p>大多数程序包含大量的逻辑和点点文本数据，编程语言被设计成适合做这样的 事情。但是有些编程任务只需要点点逻辑和大量的文本数据，对于这样的任务， 我们希望有一个更合适工具来做。模板引擎就是这样一个工具。在这一章，我 们会开发一个简单的模板引擎。</p>
<p>一个最常见的需要处理多文本数据的例子是web应用。web应用的一个重要部分 是为浏览器生成HTML网页。很少网页是完全静态的，它们至少包含一些动态数 据，比如用户名。一般情况下，网页有很大一部分动态数据：产品列表，好友消息更 新等等。</p>
<p>同时，每个HTML网页包含大量的静态文本。并且这些网页很大，有成千上万个 字节。这时，web开发者就有一个问题要解决：怎样才能最有效的生成同时包 含静态和动态数据的长字符串？随之而来的问题，这些静态文本其实是前端工 程师写的HTML，他们想希望用自己熟悉的方法处理这些HTML。</p>
<p>为了说明，让我们假设想生成这样一个简单的HTML</p>
<pre class="code literal-block"><span></span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Welcome, Charlie!<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Products:<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>Apple: $1.00<span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>Fig: $1.50<span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>Pomegranate: $3.25<span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
</pre>


<p>这里，用户名会是动态的，产品的名称和数量也是动态的，甚至产品的数量也 不是固定的：在其他情况，可能有更多或更少的产品。</p>
<p>一个简单的方法生成这样的网页是把这样的字符串作为常量写入我们的代码中， 然后把它们拼在一起完成这个网页。动态数据使用类似字符替换的方法插入进 去。有些动态数据是重复的，比如产品列表，这就是说我们会有一些重复的 HTML段，所以我们要单独的去处理它们再和其他的HTML合并起来。</p>
<p>使用这种方法生成我们的HTML的代码会像这样</p>
<pre class="code literal-block"><span></span><span class="c1"># The main HTML for the whole page.</span>
<span class="n">PAGE_HTML</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">&lt;p&gt;Welcome, {name}!&lt;/p&gt;</span>
<span class="s2">&lt;p&gt;Products:&lt;/p&gt;</span>
<span class="s2">&lt;ul&gt;</span>
<span class="s2">{products}</span>
<span class="s2">&lt;/ul&gt;</span>
<span class="s2">"""</span>

<span class="c1"># The HTML for each product displayed.</span>
<span class="n">PRODUCT_HTML</span> <span class="o">=</span> <span class="s2">"&lt;li&gt;{prodname}: {price}&lt;/li&gt;</span><span class="se">\n</span><span class="s2">"</span>

<span class="k">def</span> <span class="nf">make_page</span><span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="n">products</span><span class="p">):</span>
    <span class="n">product_html</span> <span class="o">=</span> <span class="s2">""</span>
    <span class="k">for</span> <span class="n">prodname</span><span class="p">,</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">products</span><span class="p">:</span>
        <span class="n">product_html</span> <span class="o">+=</span> <span class="n">PRODUCT_HTML</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prodname</span><span class="o">=</span><span class="n">prodname</span><span class="p">,</span> <span class="n">price</span><span class="o">=</span><span class="n">format_price</span><span class="p">(</span><span class="n">price</span><span class="p">))</span>
    <span class="n">html</span> <span class="o">=</span> <span class="n">PAGE_HTML</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">username</span><span class="p">,</span> <span class="n">products</span><span class="o">=</span><span class="n">product_html</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">html</span>
</pre>


<p>这样可以，但是我们搞得乱七八糟，HTML成了我们代码里的字符串常量，我们 很难看出这个HTML的结构，因为它被分成一段一段的了。数据格式的细节迷失 在python代码中。并且，为了修改HTML，我们的前端工程师需要修改python代 码。想象一下，如果这个网页比现在这个复杂10倍（或者100倍）我们代码会 是什么样子。</p>
<h3>Templates</h3>
<p>更好的方法是用模板来生成HTML，或者说把HTML写成一个模板，这样绝大部分 就是静态HTML，再加上一点使用特别符号的动态内容。现在我们的toy网页就成了 下面这样的模板</p>
<pre class="code literal-block"><span></span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Welcome, {{user_name}}!<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Products:<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
{% for product in product_list %}
    <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>{{ product.name }}:
        {{ product.price|format_price }}<span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
{% endfor %}
<span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
</pre>


<p>这里我们关注的是HTML文本，另外加上一点逻辑。对比现在以文本为中心的方 法和之前以逻辑为中心的方法，我们之前的程序大部分是python代码，这里我 的程序大部分是静态的HTML标签。</p>
<p>在模板中采用的以静态为主的风格和大多数编程语言的工作方式相反。比如 python，几乎所有的源文件都是可执行代码，如果你需要静态文本，你就要把 它嵌到字符串中。</p>
<pre class="code literal-block"><span></span><span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">"Hello world!"</span><span class="p">)</span>

<span class="n">hello</span><span class="p">()</span>
</pre>


<p>当python读取这个源文件时，它把<code>def hello():</code>这样的文本解释成要被执行 的指令，而在双引号中的字符 <code>print("Hello, world!")</code>被指示成文本。这 就是编程语言如何工作的：动态的，嵌入点点静态内容。静态的内容通过双引号来指示。</p>
<p>一个模板语言把这个过程反过来了，大部分是静态文本，用特殊的符号指示动态 内容。</p>
<p><code>&lt;p&gt;Welcome, {{user_name}}!&lt;/p&gt;</code></p>
<p>这里的文本会直接出现在最终的HTML中，直到遇到 <code>{{</code> 符号，它指示转换到 动态模式，这里<code>user_name</code>变量就会被替换。</p>
<p>字符串格式化函数，比如python的 <code>"foo = {foo}!".format(foo=17)</code>就是一 个在字符串并插入数据创建文本的微型语言的例子。模板更进一步，加上逻辑结构，比如条件，循环。这只是在程度上不同。</p>
<p>把这些文件叫做模板是因为它们被用来生成大量结构相似的网页，只是细节不同。</p>
<p>为了在程序中使用HTML模板，我们需要一个模板引擎(template engine)：一个需要两个参数的函数，一个是描述页面结构和内容的静态模板，另一个是包含要插入到模板中的动态数据的上下文。模板引擎把模板和上下文结合起来生成完整的HTML字符串，它的任务是解释模板，用真正的数据替换动态的部分。</p>
<p>顺便说一下，HTML对模板引擎并没有什么特别的地方，它可以用来生成任何文本数据。比如，它可以被用来生成纯文本的email信息。但是它通常用于HTML，或许碰巧还有些专门对HTML的特性，比如转义，这个特性让你不用担心插入了对HTML有特殊含义的字符。</p>
<h3>Supported Syntax</h3>
<p>不同的模板引擎在语法支持上各有不同。我们的模板语法基于Django，一个非常流行的网站框架。因为我们的引擎使用python实现的，一些python的概念会出现在我们的语法中。在上一节的HTML中我们已经看到了一些语法，这里是我们语法的小总结。</p>
<p>上下文中的数据插入到两个大括号中</p>
<p><code>&lt;p&gt;Welcome, {{user_name}}!&lt;/p&gt;</code></p>
<p>在模板中可用的数据在上下文中，后面我们详细的讲到。</p>
<p>我们的模板引擎提供了一个简单自由的语法访问数据中的元素。在python中，这些表达式有不同的效果：</p>
<pre class="code literal-block"><span></span><span class="nb">dict</span><span class="p">[</span><span class="s2">"key"</span><span class="p">]</span>
<span class="n">obj</span><span class="o">.</span><span class="n">attr</span>
<span class="n">obj</span><span class="o">.</span><span class="n">method</span><span class="p">()</span>
</pre>


<p>在我们的语法中，所有这些操作都用点号表示。</p>
<pre class="code literal-block"><span></span>dict.key
obj.attr
obj.method
</pre>


<p>这个点号会访问对象的属性，字典里的值，如果结果是可调用的，那么就自动调用它。这与python代码不同，你需要不同的语法完成不同的操作。在我们简单的语法下会是这样：</p>
<p><code>&lt;p&gt;The price is: {{product.price}}, with a {{product.discount}}% discount.&lt;/p&gt;</code></p>
<p>点号可以在一个值上多次使用以访问元素链。</p>
<p>你还可以使用帮助函数，把它们叫做过滤器，用管道符号调用</p>
<p><code>&lt;p&gt;Short name: {{story.subject|slugify|lower}}&lt;/p&gt;</code></p>
<p>制作有趣的网页通常需要一点逻辑，所以我们有条件表达式：</p>
<pre class="code literal-block"><span></span>{% if user.is_logged_in %}
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Welcome, {{ user.name }}!<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
{% else %}
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">"/login"</span><span class="p">&gt;</span>Log in <span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
{% endif %}
</pre>


<p>循环可以让我们在网页里包含数据集合：</p>
<pre class="code literal-block"><span></span><span class="nt">&lt;p&gt;</span>Products:<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;ul&gt;</span>
<span class="cp">{%</span> <span class="k">for</span> <span class="nv">product</span> <span class="k">in</span> <span class="nv">product_list</span> <span class="cp">%}</span>
    <span class="nt">&lt;li&gt;</span><span class="cp">{{</span> <span class="nv">product.name</span> <span class="cp">}}</span>: <span class="cp">{{</span> <span class="nv">product.price</span><span class="o">|</span><span class="nf">format_price</span> <span class="cp">}}</span><span class="nt">&lt;/li&gt;</span>
<span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span>
<span class="nt">&lt;/ul&gt;</span>
</pre>


<p>和其他的编程语言一样，条件和循环可以嵌套使用。</p>
<p>最后，我们可以对模板注释</p>
<p><code>{# This is the best template ever! #}</code></p>
<h3>Implementation Approaches</h3>
<p>粗略的说，模板引擎有两个主要的部分，解析和呈现。</p>
<p>对于模板的呈现包括下面这几个部分： 
- 管理动态上下文，它是数据的来源 
- 执行逻辑元素
- 执行数据访问和过滤器</p>
<p>解析模板后应该传递什么给下一步是个关键问题。解析模板输出什么？这里有两个选择：我们称它们为<code>解释</code>(interpretation) 和<code>编译</code>(complilation), 这是借用其他语言实现的术语。</p>
<p>使用解释模式，解析产出一个代表模板结构的数据结构，呈现部分会一步一步的处理这个数据结构，组合它发现的文本数据。作为一个真实的例子，Django的模板引擎就是使用这种方法。</p>
<p>编译模式，解析后直接产出某种形式的可执行代码，呈现部分就会执行这个代码产出结果。Jinja2和Mako是使用编译方法的模板引擎的例子。</p>
<p>我们的模板引擎使用编译的方式实现。我们把模板编译成python代码，执行它，产生结果。</p>
<p>这里描述的模板引擎起源于covery.py的一部分，它用来生成HTML报告，在coverage.py中只有几个模板，它们被频繁的使用，总之，如果模板被编译成python代码的话程序会更快，即使编译过程有点复杂。编译一次，运行多次。这会比解释一个数据结构快很多倍。</p>
<p>编译过程有点复杂，但不是你想象的那么难。并且可能有开发者告诉你一个自己能写程序的程序会更有趣些。</p>
<p>我们的模板编译器是一个通用技术的小例子，叫做代码生成器。代码生成是很多强大灵活的工具的基础，包括语言编译器。代码生成器可能非常复杂，但是它会是你工具箱里的一个有用的工具。</p>
<h3>Compiling to Python</h3>
</div>
    </div>
    </article>
</div>



        
       <script>var disqus_shortname="ls-a";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2018         <a href="mailto:845767657@qq.com">Tao Qingyun</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
        </footer>
</div>
</div>


            <script src="assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
